---
title: 《C陷阱与缺陷》笔记
date: 2023-10-14 21:33:51
tags:
---
# 声明变量与类型转换

## 类型转换

假如现在要声明一个 `float` 变量：

```c
float f;
```

那么当我们进行类型转换时，只要把_；_ 和 _变量名_ 去掉，并在类型外面加上_一对括号_ 即可：

```c
(float) a;
```

利用类型转换的原则，我们可以发现：

```c
float (*pf)();
```

声明了一个函数指针，由此，要把某个变量转换为函数指针：

```c
(float (*)())
```

现在你可以理解下列语句的意思了：

```c
(* (void (*)()) 0))();
```

我们也可以使用 `typedef` 来让这个语句看起来更漂亮一些：

```c
typedef void (*funcptr)(); 
// 更准确的意思可以表达为： typedef void (*)() funcptr;
// 但这不是正确的语法

(*(funcptr) 0))();
```

但是，为什么不能使用：

```c
typedef void (*)() funcptr;
```

呢？

我猜原因是这里C语言应用的逻辑是 _声明_ 而不是 _类型转换_ . 

（尽管 `typedef void (*)() funcptr;` 这种写法更符合逻辑，也更易懂）

对于一个函数，可以利用类似的思想来理解：

```c
float fun(...);
```

表示声明 `fun(...)` 是一个 `float` 类型的变量，即它的返回值是 `float` 类型的变量。

而之所以在上面 `typedef` 的例子中要这么定义，同样也是和声明有关：

```c
// 下面是一个声明返回值为 void 的函数指针的声明方法
void (*fun)(int);

// 把 funcptr 作为 void (*)() 的别名时，需要使用声明的语法
typedef void (*funcptr)();
// 同理：
typedef int uint32;
```

同样的，声明一个返回函数指针的函数时（以`signal()` 函数为例）：

```c
// 下面是一个声明返回值为 void 的函数指针的声明方法
void (*fun)(int);

// 由声明函数指针的方法知道我们要把signal这个函数的返回值声明为一个“返回值为 void 的函数指针”
// 的方法：
// 去掉变量名: void (*)(int)
// signal的参数为一个int和一个函数指针，将 signal(int, void (*)(int)) 放进去

// 应用规则，一个返回值为函数指针的函数应该声明为：
void (*(signal(int, void (*)int)))(int);
```



# 语法陷阱

## 指针和数组

- C语言只有**一维数组**，且数组的大小在编译时必须为一个恒常数。而数组的成员可以为任意类型，包括数组，这使得构建多维数组成为可能。
- 对数组只有两种操作：确定它的大小和获取第0个元素的指针。**所有**的数组操作都是通过指针完成的。所有的下标操作都相当于指针操作。

- 除了作为关键字sizeof的操作数时，数组的变量名代表整个数组（因此返回的参数为数组的实际大小），其他时候都被转换为代表数组的首元素指针。ANSI C不允许 `p = &a` 这种写法，但在某些情况下 `&a` 代表“整个数组的地址”

- 字符串：

```c
// 假定我们有字符串s和t
char *r;
strcpy(r, s);
strcat(r, t);
```

上面这种写法是错误的，因为不知道`r`指向何处，我们需要使用`malloc`或声明为`char r[100]`给`r`分配空间。

- 数组作为参数传递时，实际上是传递了一个首元素的指针。
- 逗号运算符：

```c
// 在函数参数中，逗号不是运算符
fun(a, b);
// 而当逗号作运算符的时候，逗号左边的值先运算，随后被丢弃
g((a,b));
```



