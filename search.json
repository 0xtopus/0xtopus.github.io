[{"title":"DSP知识整理","url":"/dsp知识整理/","content":"\n\n推荐参考书籍：《手把手教你学DSP—基于TMS320X281x》（第3版） *顾卫钢*\n\n# 一、DSP概述\n\n### 硬件：\n- 高速控制和信号处理\n- 采用流水线操作\n- 采用哈佛结构，数据存储区和程序存储区分离，数据总线和程序总线也是分开的\n- 大多配有硬件乘法器和加法器，同一时钟周期内可以完成累加和累乘\n- 零开销循环\n\n### 软件：\n- 显示MAC（乘加器）指令\n- 精简指令集\n- 专门的寻址方式\n\n### DSP分类\n按数据格式分：\n- 定点\n- 浮点\n\n按用途分：\n- 通用\n- 专用\n\n### DSP的应用\n1. 数字电机控制\n2. 数字电源供应\n3. 高级传感器\n4. ...\n\n\n# 二、TMS320F2812\n\n### C2000系列DSP\n1. Piccolo系列\n   - F2802x, F2803x/5x, F2806x\n2. Delfino系列\n   - F2833x/23x, C2834x, F2837xS, F2837xD \n\n### CPU\n\n- 32位定点CPU\n- 150MHz\n- 当频率为135MHz时，核心电压1.8V；当频率为150MHz时，核心电压为1.9V；输出IO口电压为3.3V\n\n### 内存\n\n- 18kW RAM\n- 128kW Flash\n\n### 总线\n\n- 3条地址总线\n  - PAB：程序地址总线，**22位**\n  - DRAB：数据读地址总线，32位\n  - DWAB：数据写地址总线，32位\n- 3条数据总线\n  - DRDB：数据读数据总线，32位\n  - DWDB：数据写数据总线，32位\n  - PRDB：程序读数据总线，32位\n\n### 外设功能模块\n- 控制类\n  - IO\n  - 定时器\n  - PWM\n\n- 测量类\n  - 数字：捕获、正交编码\n  - 模拟：ADC\n\n- 通讯类\n  - UART\n  - eCAN\n  - SPI\n  - McBsp\n\n### 其他\n外设中断扩展模块（PIE）\n- 支持45个外部中断\n\n片上存储器\n- 128kW Flash，受到CSM（Code Security Module）保护\n- 1kW的OTP型存储器（一次性可编程ROM），受到CSM的保护；\n- 18kW的SARAM\n  - L0和L1：两个4kW的SARAM, 受到CSM的保护\n  - H0: 8kW\n  - M0和M1：两个1kW的SARAM\n- 56个可编程IO口\n- 时钟和系统控制\n- 3个32位CPU定时器\n- 马达控制外设\n  - 两个事件管理器\n- 12位ADC，16通道\n\n### 寻址方式\n\n1. 直接寻址\n2. 间接寻址\n3. 寄存器寻址\n4. 堆栈寻址\n5. 数据/地址/IO空间立即寻址方式\n6. 程序空间间接寻址方式\n\n### C28x流水线\n- 八级流水线，五个阶段\n- 取指令，译码，读取数据，执行，写回\n\n# 三、时钟和系统控制\n![OSC&PLL](../img/DSP/OSC&PLL.png)\n时钟CLKIN的来源有两种，一种是外部晶振提供，另一种是外部时钟输入。可以通过引脚<span style=\"text-decoration: overline\">XF_PLLDIS</span>来控制选择。\n\n- 晶振：20MHz ~ 35MHz\n- 外部时钟：有PLL: 5 ~ 100MHz；无PLL: 4 ~ 150MHz\n\n在使用对应的外设之前，需要使能它们的时钟。与外设时钟使能相关的寄存器是<u>外设时钟使能寄存器PCLKCR</u>。\n\nSYSCLK经过分频可以得到低速外设时钟LSPCLK和高速外设时钟HSPCLK，它们互相独立，分别给高速外设和低速外设供应时钟信号。\n\n<img src=\"..\\img\\DSP\\HSPCLK_LSPCLK.png\" style=\"zoom:75%;\" />\n\n\n\n### 看门狗电路\n\n当八位的<u>看门狗加法计数器WDCNTR</u>达到最大值时，看门狗模块输出一个512个周期的脉冲，使系统复位。\n\n如果不想使用看门狗，可以直接禁止看门狗。\n\n如果启用了看门狗，当程序正常运行时，我们需要定期向WDCNTR依次顺序写入0x55和0xAA来清零，实现“喂狗”操作。\n\n逻辑校验位是看门狗的另一个安全机制，访问<u>看门狗控制器WDCR</u>的写操作中，相应的校验位必须为“101”，否则会立即拒绝访问并引发系统复位。\n\n### 低功耗模式\n- 空闲模式：CPU进入低功耗模式，部分外设不使用时时钟选择性关闭，会自动降低频率来降低功耗，任何使能的外设中断都可以唤醒此模式。\n- 暂停模式：片上所有设备停止工作\n- 备用模式：关闭CPU和外设时钟，OSC和PLL正常工作\n\n# 四、CPU定时器\n\nx2812内部有3个32位的CPU定时器，其中只有Timer0可供用户使用，Timer1和Timer2都被系统保留。\n\n欲使用CPU定时器来计时，需要设置两个寄存器：\n\n- 周期寄存器 PRDH:PRD\n- 分频器寄存器 TDDRH:TDDR\n\n计数器的周期有以下两个公式：\n\n${TIMCLK = \\frac{TDDRH:TDDR + 1 }{SYSCLK} * 10^{-6}}$\n\n${Period = (PRDH:PRD + 1) * TIMCLK}$\n\n# 五、编程\n\n## 程序文件\n\n- 源程序文件：C，汇编文件\n- 头文件：.h文件\n- 命令文件(cmd)：对程序和数据存储空间进行分配\n- 运行支持库\n\n## 命令文件\n\n伪指令：\n\n- MEMORY：用来指示存储空间\n  - PAGE0：程序空间\n  - PAGE1：数据空间\n- SECTION：用来分配到储存空间\n  - 段：\n    - .cinit：存放用来对全局和静态变量初始化的函数\n    - .text：存放编译C语言时产生的汇编代码\n    - .econst：包含字符串常量、全局变量和静态变量的初始化和说明\n    - .ebss：使用大寄存器模式时为全局变量和静态变量所预留的空间\n    - .stack：为系统堆栈保留的空间，主要用于函数传递变量和为局部变量分配空间。\n\n# 六、GPIO\n\n总共56个可编程复用IO口，分为ABDEFG六组。复位默认为输入口。可提供4mA输入电流。\n\n寄存器：\n\n- GPxMUX\n  - 写0，设置为数字IO口\n  - 写1，功能复用\n- GPxDIR\n  - 写0，输入\n  - 写1，输出\n- GPxDAT\n  - 写0，拉低输出\n  - 写1，拉高输出\n  - 存在一定的问题，建议使用下面三个寄存器来操作\n- GPxSet：只能写1\n- GPxClear：只能写1\n- GPxTOGGLE：只能写1\n\n```c\n// 置位输出\nGpioDataReg.GPASET.bit.GPIOA0 = 1;\n// 读取输入\nif(GpioDataReg.GPASET.bit.GPIOA2 = 0) {\n    ...\n}\n```\n\n \n\n# 七、中断\n\n中断的类型：\n\n- 触发形式\n  - 软件中断\n  - 硬件中断\n    - 内部中断\n    - 外部中断\n- 能否屏蔽\n  - 可屏蔽中断\n  - 不可屏蔽中断\n\n## 中断优先级\n\n在不同组内INT1最大，在PIE同组内，INTx.1最大。\n\n## CPU级中断\n\nCPU中的中断由IER和INTM控制。IER控制每个可屏蔽中断，INTM相当于总闸。\n\n## PIE中断\n\n外设中断扩展模块（PIE），对各种中断请求源进行处理。\n\nPIE一共支持96个中断，这些中断被分为了12个组，每组由8个中断。每个组都被反馈到 <span style=\"text-decoration:overline\" >INT1</span> ~ <span style=\"text-decoration:overline\" >INT12</span> 这12条中断线上的某一条。\n\n## PIE中断向量表\n\nDSP中各个中断服务子程序的地址储存在一片连续的RAM（大小为256x16）内，这就是中断向量表。\n\n## 2812的三级中断系统\n\n三级系统都要允许，某中断才会发生。\n\n- 外设级\n\n  - 当外设中断标志位被置1，且该外设中断为使能状态，此时外设向PIE发出中断请求；\n  - <span style=\"color:red; font-weight:bold\">外设中断标志位置位后必须<u>手动清除</u>！！！</span>\n\n  ```c\n  CpuTimer0Reg.TCR.bit.TIF = 1;\t// 写1来手动清除外设寄存器中的标志位\n  ```\n\n  \n\n- PIE级\n\n  - 除了中断标志寄存器和中断使能寄存器，还有中断应答寄存器。\n  - 同组内的中断在响应时，如果发生了其他同组中断，若中断应答寄存器没有被手动清零，后发生的中断不会被响应。<span style=\"color:red; font-weight:bold\">中断应答寄存器需要手动清除</span>。PIE级中断的标志位不需要手动清除。\n\n  ```c\n  PieCtrl.PIEACK.bit.ACK1 = 1;\n  ```\n\n  \n\n- CPU级\n\n  - 当外设中断请求发送到CPU时，CPU的中断标志寄存器IFR对应位置位。这时，CPU检查IER对应的位是否置位，以及INTM是否<span style=\"color:red; font-weight:bold\">为0</span>。\n\n<img src=\"..\\img\\DSP\\INTERRUPTION.png\" style=\"zoom:75%;\" />\n\n## 中断函数的编写\n\n1. 使能某个中断：\n\n```c\nvoid InitXXX(void) {\n    ...\n    CpuTimer0Regs.TCR.bit.TIE = 1;\t// 使能定时器0的周期中断\n    ...\n}\n```\n\n2. 在主函数里：\n\n```c\nvoid main(void) {\n    InitXXX();\n    DINT;\n    IER = 0x0000;\n    IFR = 0x0000;\n    InitPieCtrl();\n    InitPieVectTable():\n    // 使能PIE的中断\n    PieCtrl.PIEIER1.bit.INTx7 = 1;\n    IER |= M_INT1;\n    EINT;\n}\n```\n\n3. 在DSP28_DefaultIsr.c文件里配置中断函数\n\n```c\ninterrupt void TINT0_ISR(void) {\n    ...\n    CpuTimer0Regs.TCR.bit.TIF = 1;\n    PieCtrl.PIEACK.bit.ACK1 = 1;\n    EINT;\n}\n```\n\n\n\n# 八、EV模块（事件管理器）\n\n两个事件管理器Eva和Evb，两个事件管理器的功能是一模一样的。\n\n下面**针对Eva**来介绍事件管理器的结构：\n\n- 2个16位通用定时器，每个定时器可以产生1路独立的PWM波。\n- 3个比较单元\n- 3个捕获单元\n- 1个正交编码脉冲电路\n\nEvb和Eva类似。\n\n## 通用定时器\n\n### 功能\n\n1. 计时\n2. 使用定时器的比较功能产生PWM波\n3. 给Ev的其他模块提供时钟\n\n### 寄存器\n\n**GPTimer1**的寄存器们be like:\n\n- 16位周期寄存器T1PR（带有阴影寄存器）\n- 16位比较寄存器T1CMPR（带有阴影寄存器）\n- 定时器计数器寄存器T1CNT\n- 16位控制寄存器T1CON\n- 16位通用定时器控制寄存器GPTCONA\n\n### 通用定时器的时钟\n\nSYSCLK  --> HSPCLK --> TCLK\n\n$TCLK = \\frac{HSPCLK}{2^{p}}$\n\n其中，p = 1 ~ 128\n\n### 计数方式\n\nGPTimer1通过T1CON的TMODE1和TMODE0控制计数方式。\n\n| TMODE1 | TMODE0 |       描述        |\n| :----: | :----: | :---------------: |\n|   0    |   0    |   停止/保持模式   |\n|   0    |   1    | 连续增/减计数模式 |\n|   1    |   0    |  连续增计数模式   |\n|   1    |   1    | 定向增/减计数模式 |\n\n对定向增/减计数模式的说明：当为定向增/减计数模式时，计时器工作在递增还是递减模式取决于引脚TDIRA的电平，高电平递增，低电平递减。\n\n### 中断事件\n\n- 上溢中断\n- 下溢中断\n- 比较中断\n- 周期中断\n\n### PWM波\n\n要产生PWM波：\n\n- 使能定时器的T1CON的TECMPR位为1（比较使能）\n- GPTCONA的TCMPOE位为1（输出使能）\n\n此时，T1PWM_T1CMP引脚输出PWM波。当T1CNT与T1CMPR的值相匹配时，引脚T1PWM_T1CMP电平就会发生跳变。\n\n产生的PWM波有两种：\n\n- 不对称（连续增计数模式）\n- 对称（连续增\\减计数模式）\n\n可以配置GPTCONA的T1PIN[1:0]位控制输出的极性：\n\n| 位1  | 位0  |    描述    |\n| :--: | :--: | :--------: |\n|  0   |  0   |   强制低   |\n|  0   |  1   | 低电平有效 |\n|  1   |  0   | 高电平有效 |\n|  1   |  1   |   强制高   |\n\n低电平有效就是T1CNT的值比T1CMPR小的时候输出高电平，其他以此类推。\n\n定时器的周期为：\n\n非对称模式：\n\n$T = (T1PR + 1) * TCLK$\n\n对称模式：\n\n$T = (2 * T1PR) *TCLK$\n\n## 全比较单元\n\nEva、Evb各有3个全比较单元（加起来总共6个），每个比较单元都可以输出2路互补的PWM波，所以Eva或者Evb可以都有能力驱动一个三相全桥电路。（当然你也可以设置输出的两路PWM相同）\n\n### 寄存器\n\n按Eva和Evb来分：\n\n- 16位比较寄存器CMPR1~3， CMPR4~6，共6个（都有阴影寄存器）\n- 16位比较控制寄存器COMCONA和COMCONB，共2个\n- 16位行为控制寄存器ACTRA和ACTRB（都有阴影寄存器）\n\n以Eva为例，输出的PWM极性可以通过ACTRA的位CMP1和CMP2控制。使能COMCONA的CENABLE和FCMPOE位时即可产生两路互补的PWM波。\n\n每个比较寄存器都有两个对应的PWM输出引脚：比如CMPR1对应PWM1和PWM2\n\n输出的PWM波类型和GPTimer是一样的。只是把T1CMPR改成CMPRx即可。\n\n带有死区控制的PWM不考，不写了。\n\n## 捕获单元\n\n捕获单元能够捕获外部输入引脚CAPx_QEPx的电平变化。当捕获到指定的电平变化时，捕获单元就记录下定时器的时间。利用两次捕获的时间差，捕获单元就可以测量出信号的脉宽。\n\n2812的Eva和Evb各有三个捕获单元CAP1 ~ 3和CAP4 ~ 6。每个捕获单元都有一个捕获输入\n\n引脚，通过配置相关寄存器可以捕获输入波形的上升沿、下降沿或者同时捕获上升沿和下降沿。当引脚检测到指定的变化时，所选用的定时器的值将被捕获并锁存到对应的2级FIFO堆栈中。注意，从引脚发生变化到锁存定时器的值需要至少2个时钟周期，所以**输入信号至少要保持2个时钟周期**。\n\n### 寄存器\n\n- 捕获控制寄存器CAPCONA, CAPCONB\n- 捕获FIFO状态寄存器CAPFIFOA， CAPFIFOB\n- 两级深度的FIFO堆栈CAPFIFOx, CAPFBOTx (x = 1 ~ 6)\n\n以Eva的CAP1为例，在堆栈为空的时候，捕获状态寄存器CAPFIFOA的CAP1FIFO状态位为00，发生一次捕获后，定时器计数寄存器T1CNT的值被存入栈顶，CAP1FIFO状态位为01，第二次捕获后，数据存入栈底，堆栈全满，CAP1FIFO状态位变为10；第三次捕获后，栈顶的数据出栈，第二次捕获的来到栈顶，第三次捕获的来到栈底。如果没有读取第一次捕获的值（第一次捕获的值丢失），则CAP1FIFO状态位变为11；否则如果在第三次捕获前已经读取了第一次捕获的值，则CAP1FIFO状态位仍为10.\n\n\n\n### 中断\n\n以Eva为例，捕获单元1具有捕获中断CAP1INT，捕获单元2有CAP2INT，捕获单元3有CAP3INT...\n\n中断发生的条件：\n\n1. 捕获单元捕获到信号发生指定的变化\n2. 此时CAPxFIFO不为0（堆栈非空）\n\n则此时中断标志位被置位。\n\n和中断相关的寄存器：\n\n- 中断标志寄存器EVAIFRC，EVBIFRC\n- 中断屏蔽寄存器EVAIMRC和EVBIMRC（用来使能中断的）\n\n## 正交编码电路\n\n每个事件管理器都有一个正交编码电路（QEP电路），光电码盘输出的两路正交编码信号从两个输入引脚输入到QEP电路，在通过两个QEP电路的译码器对正交编码信号进行译码，最后就能得到电机转子的转速、旋转方向、旋转位置等信息。\n\n\n\n```c\n/*\n * 自己写的事件管理器Init函数\n * 配置了全比较单元输出PWM波和捕获单元捕获上升下降沿\n */\nvoid InitEv(void)\n{\n\t/*\n\t * 配置GP Timer2\n\t */\n\tEvaRegs.T2CON.bit.TENABLE = 0; \t// 暂时禁止t2计数\n\tEvaRegs.T2CON.bit.TPS = 0;\t\t\t// 输入计数时钟为HSPCLK = 75MHz\n\tEvaRegs.T2CON.bit.TMODE = 2; \t\t// GP Timer2连续增计数模式\n\tEvaRegs.T2CON.bit.TCLKS10 = 0; \t// 选择内部时钟T2CLK\n\n\tEvaRegs.T2CNT = 0x0000;\t// Clear the counter for GP timer 2\n\tEvaRegs.T2PR = 0x3A97;\t\t// 频率为5kHz，PR = 14999\n\n\t/*\n\t * GP Timer2周期中断配置\n\t*/\n\tEvaRegs.EVAIMRB.bit.T2PINT = 1;\t\t// 使能GP Timer2周期中断\n\tEvaRegs.EVAIFRB.bit.T2PINT = 1;\t\t\t// 复位GP Timer2周期中断标志位\n\n\n\t/*\n\t * 配置GP Timer1\n\t */\n\tEvaRegs.T1CON.bit.TENABLE = 0; \t// 暂时禁止t1计数\n\tEvaRegs.T1CON.bit.TPS = 0;\t\t\t// 输入计数时钟为HSPCLK = 75MHz\n\tEvaRegs.T1CON.bit.TMODE = 2; \t\t// GP Timer1连续增计数模式\n\tEvaRegs.T1CON.bit.TCLKS10 = 0; \t// 选择内部时钟T1CLK\n\n\tEvaRegs.T1CNT = 0x0000;\t\t// Clear the counter for GP timer 1\n\tEvaRegs.T1PR = 0x3A97;\t\t// 频率为5kHz，PR = 14999\n\n\t/*\n\t * 配置全比较模块\n\t */\n\tEvaRegs.COMCONA.bit.CENABLE = 1;\t\t// 使能EVA的全比较操作\n\tEvaRegs.COMCONA.bit.FCOMPOE = 1;\t// 使能比较输出\n\n\tEvaRegs.COMCONA.bit.CLD = 0;\t\t\t\t// 比较寄存器重载条件为下溢中断\n\n\tEvaRegs.CMPR1 = 0x1D4C;\t// 默认占空比为50%\n\tEvaRegs.CMPR2 = 0x1D4C;\t// 默认占空比为50%\n\tEvaRegs.CMPR3 = 0x1D4C;\t// 默认占空比为50%\n\tEvaRegs.ACTR.all = 0;\t\t\t// 全部强制低\n\n\t/*\n\t * GP Timer1下溢中断配置\n\t */\n\tEvaRegs.EVAIMRA.bit.T1UFINT = 1;\t\t// 使能GP Timer1下溢中断\n\tEvaRegs.EVAIFRA.bit.T1UFINT = 1;\t\t// 复位GP Timer1下溢中断标志位\n    \n    \n    EvaRegs.CAPFIFO.all = 0; // 初始化CAPFIFOA\n\n\tEvaRegs.CAPCON.bit.CAPRES = 0; \t\t\t// 清零捕获寄存器\n\tEvaRegs.CAPCON.bit.CAPQEPN = 1; \t\t// 使能捕获单元1,2\n\tEvaRegs.CAPCON.bit.CAP3EN = 1;\t\t\t// 使能捕获单元3\n\tEvaRegs.CAPCON.bit.CAP3TSEL = 1;\t\t// 捕获单元3时基为timer1\n\tEvaRegs.CAPCON.bit.CAP12TSEL = 1;\t\t// 捕获单元1,2时基为timer1\n\n\tEvaRegs.CAPCON.bit.CAP1EDGE = 0x3;\t// 捕获单元1捕获边沿为上升下降沿\n\tEvaRegs.CAPCON.bit.CAP2EDGE = 0x3;\t// 捕获单元2捕获边沿为上升下降沿\n\tEvaRegs.CAPCON.bit.CAP3EDGE = 0x3;\t// 捕获单元3捕获边沿为上升下降沿\n\n\tEvaRegs.EVAIMRC.bit.CAP1INT = 1;\t\t// 使能捕获单元1中断\n\tEvaRegs.EVAIMRC.bit.CAP2INT = 1;\t\t// 使能捕获单元2中断\n\tEvaRegs.EVAIMRC.bit.CAP3INT = 1;\t\t// 使能捕获单元3中断\n\tEvaRegs.EVAIFRC.all = 0x7;\t\t// 复位捕获单元中断标志位\n\n\tEvaRegs.T1CON.bit.TENABLE = 1; \t// 使能t1计数\n\n}\n```\n\n\n\n# 九、ADC\n\n- 2812的ADC分辨率为12bit，具有流水线结构，具有16个通道，分为2组：一组为ADCINA0 ~ ADCINA7，另一组为ADCINB0 ~ ADCINB7，分别对应两个采样保持器。虽然通道很多，但是转换器只有一个，所以要对各通道进行排序转换。\n\n- ADC模块的时钟最高频率为25MHz，最高采样率为12.5MSPS（sample per second）。\n- ADC电压的采样范围是<u>0 ~ 3 V</u>\n- ADC模块对一个序列的通道开始转换必须要有一个启动信号来触发，当信号到来时，相应的序列发生器就开始对内部预先指定的通道进行转换。\n- ADC有两种工作模式：\n  - 两个独立的8通道\n  - 级联16个通道\n- ADC共有16个结果寄存器来存储转换的数值。\n\n## 工作方式\n\n通过16位的ADC输入通道选择序列控制寄存器ADCCHSELSEQx（x=1, 2, 3, 4）可以控制ADC通道的<u>转换顺序</u>。\n\n每个ADCCHSELSEQx被分为了4段，每段其名为：CONVxx（x = 00 ~ 15）。\n\n- 当ADC工作在**双序列发生器模式**下时，序列发生器SEQ1使用ADCCHSELSEQ1和2，每个CONVx可以选择的通道为ADCINA0 ~ 7；SEQ2使用ADCCHSELSEQ3和4，每个CONVx可以选择的通道为ADCINB0 ~ 7;\n- 当ADC工作在**级联模式**下时则都可自由选择。\n\nADC转换的<u>通道数量</u>由最大通道转换寄存器ADCMAXCONV决定。\n\n- 当工作在双序列发生器模式下时，该寄存器的低三位[0:2]所代表的**二进制数 + 1**决定SEQ1序列发生器转换的通道数量；[4:6]位决定SEQ2转换的通道数量。\n- 工作在级联模式下时，低四位[0:3]决定转换通道的数量，为其代表的**二进制数 + 1**\n\nADC还有顺序采样和并发采样两种采样方式，所以排列组合一下，就有：\n\n- 双通道顺序采样\n- 级联顺序采样\n- 双通道并发采样\n- 级联并发采样\n\n四种模式。\n\n下面是一个配置双序列顺序采样的例子：\n\n```c\n\tAdcRegs.ADCTRL1.bit.SEQ_CASC = 0; //独立双排序模式\n\tAdcRegs.ADCTRL1.bit.CONT_RUN = 0; //启动停止模式\n\n\t// 级联双排序的排序器配置\n\tAdcRegs.MAX_CONV.bit.MAX_CONV = 0x0032; // B组采样通道为4，A组采样通道为3\n\tAdcRegs.CHSELSEQ1.bit.CONV00 = 0x0; // 选择模拟通道ADCINA0\n\tAdcRegs.CHSELSEQ1.bit.CONV01 = 0x1; // 选择模拟通道ADCINA1\n\tAdcRegs.CHSELSEQ1.bit.CONV02 = 0x2; // 选择模拟通道ADCINA2\n\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xB; // 选择模拟通道ADCINB3\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xC; // 选择模拟通道ADCINB4\t\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xD; // 选择模拟通道ADCINB5\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xE; // 选择模拟通道ADCINB6\n```\n\n序列发生器的工作模式有两种：启停模式和连续转换模式。由ADCTRL1的CONT_RUN位控制。在连续转换模式下，当一次序列转换结束后，会自动从该序列头部开始重新进行转换。当工作在启停模式下的时候，序列发生器完成一次转换后会停留在最后状态，需要先**手动复位**后才能在下一次SOC（start of conversion）信号到来时才会重新开始转换。\n\n```c\nAdcRegs.ADCTRL2.bit.RST_SEQ1 = 1;  // 手动复位序列发生器\n```\n\n## 结果读取\n\nADC的采样结果存储在16个16位的ADC结果寄存器里，左对齐，结果占据高12位，所以计算的时候需要右移4位。\n\n$(ADResult >> 4) = \\frac{(V_{i}  - ADCCLO)}{3 V} *4095$\n\nADCLO一般接模拟地，所以为0：\n\n```c\nres = (AdcRegs.RESULT0 >> 4) / 4095 * 3;\n```\n\n\n\n# 十、SPI\n\n串行外设接口，是一种**低速同步串行通信接口**，而SCI是同步通信。\n\n- 异步通信和同步通信的区别在于**收发双方是否使用同一个时钟信号来控制数据收、发移位操作**。\n\n## 工作方式\n\nSPI总线至少包含一根时钟线和数据线。2812使用4线制SPI，以主从方式进行工作，全双工通信。通信系统中通常有一个主设备和多个从设备。\n\n|                     线路名称                     |           功能           |\n| :----------------------------------------------: | :----------------------: |\n|                       SCK                        | 串行时钟线（主设备控制） |\n|                       MISO                       |    主机输入/从机输出     |\n|                       MOSI                       |    主机输出/从机输入     |\n| <span style=\"text-decoration:overline\">CS</span> | 是低电平有效的从机选择线 |\n\nSPI的波特率 = SPICLK <= LSPCLK/4。实际使用时要确保小于从机的最大允许速率。\n\n<img src=\"..\\img\\DSP\\spi.png\" alt=\"spi\" style=\"zoom:75%;\" />\n\n"},{"url":"/git_note/","content":"# git配置\n\n`git config --global user.name \"...\"`\n\n`git config --global user.email\"...\"`\n\n# 使用git\n\n`git status`: 查看当前目录的文件状态\n\n`git init` :初始化仓库\n\n# 文件状态\n\n- 未跟踪\n\n- 已跟踪\n\n  - 暂存：文件已修改且保存，但还没有提交到git仓库\n  - 未修改\n  - 已修改\n\n  \n\n  刚刚添加到仓库的文件是未跟踪状态。\n\n  `git add 文件名` ：将文件从**未跟踪**切换到**暂存**的状态\n\n  `git add *`：将所有已修改 (未跟踪) 的文件暂存\n\n  `git add -u`：只对**已跟踪文件**有效，把所有已修改的已跟踪文件暂存\n\n  `git add -A`：把所有的变化（包括删除的和添加的文件）暂存\n\n  `git commit -m \"<message>\" `：将**暂存**的文件存到仓库里, message是本次提交的日志信息，状态变成 **未修改**\n  \n  `git commit -a -m \"<message>\"`:提交所有已修改的文件\n  \n  文件发生变化时，变成**已修改**的状态\n\n​\t\t`git log`：查看历次提交的记录\n\n​\t\tbouns: `git log --pretty=oneline`\n\n可以在vscode里使用图形化界面git\n\n# 常用命令\n\n1. 重置文件\n\n```bash\ngit restore <filename> \n#修改后，还未暂存时，可以用来恢复文件\n\ngit restore --stage <filename> #取消暂存状态，不会取消删除的文件\n```\n\n如果要取回被删的文件，还要再restore一下\n\n\n\n2. 恢复某版本的某文件\n\n   ```bash\n   git checkout 9f955d85359fc8e4504d7220f13fad34f8f2c62b ./recipes/tofu\n   ```\n\n   - 恢复版本`9f955d85359fc8e4504d7220f13fad34f8f2c62b`的文件`./recipes/tofu`\n   - 注意，`checkout`命令不会改变提交记录，且必须==指定要恢复的文件名==，否则会出现bug（如遇此种情况，见：[Git WTFs](https://sp18.datastructur.es/materials/guides/git-wtfs.html)）\n   - 回滚之后，需要再`commit`一次。\n\n   \n\n3. <span id=\"change-commit-messages\">修改最近的提交注释信息</span>：\n\n   ```bash\n   git commit --amend\n   ```\n\n   更多请参考：https://blog.csdn.net/qq_17011423/article/details/104648075\n\n   - 修改前几次的提交注释信息：https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/changing-a-commit-message\n\n   \n\n4. 删除文件\n\n```bash\ngit rm <filename>\ngit rm -f <filename> #强制删除\n\n```\n\n\n\n\n5. 移动文件（重命名）\n\n```bash\ngit mv from to #移动文件/重命名文件\n```\n\n# 分支\n\ngit在commit文件时，每次都会创建一个节点，记录代码的状态。\n\n节点会构成一个树状结构，存在分支。\n\n默认情况下，只有一个分支，叫做 \"master\"\n\n```bash\ngit branch #查看当前分支\ngit branch <branch name> #新建一个分支\ngit branch -D <branch name> #删除分支\ngit switch <branch name>\t#切换分支\ngit switch -c <branch name> #创建并切换分支\n```\n\n在开发中，都是在自己的分支里写代码。写好无误后，再合并分支。\n\n- 合并分支\n\n```bash\ngit switch master\t#切换到主分支\ngit merge <branch name> #合并分支\ngit branch -D <branch name> #合并之后可以删除不需要的分支\n```\n\n\n\n在装了插件的VScode里面的COMMIT DETAILS里，可以通过graph来查看所有分支的情况\n\n<img src=\"..\\img\\gitPics\\image-20221219172950437.png\" alt=\"image-20221219172950437\" style=\"zoom:50%;\" />\n\n有的时候，分支可以快速合并（fast-forward)，但有时候，合并时分支的文件之间会产生冲突。git会帮助你标识出冲突所在，这时候需要手动合并，然后暂存和提交：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>wawawa</h1>\n<<<<<<< HEAD\n    <h2>bugbug fixfix</h2>\n=======\n    <h1>jjj</h1>\n    <h1>wuwuwu</h1>\n    <ul>\n        <li>wiwdiu</li>\n    </ul>\n>>>>>>> test\n</body>\n</html>\n```\n\n# 变基(rebase)\n\n当开发分支较多时，merge会把分支树变得很乱。此时可以使用变基来合并分支。\n\n==注意：==变基操作一般只在自己的本地仓库使用，远程服务器的仓库不可以使用变基。\n\n1. 发起变基时，git会先找到两条最近分支的最近祖先\t\n2. 把当前分支和合并分支的共同祖先进行比对，把所有的变化提取出来存到一个临时文件里\n3. 将当前分支的祖先指向目标分支的基底\n4. 从当前基底开始重新执行之前临时存起来的操作\n\n```bash\ngit switch <filename>\ngit rebase <target filename>\n```\n\n### 利用变基合并commits\n\n参考：\n\n1. https://stackoverflow.com/questions/2563632/how-can-i-merge-two-commits-into-one-if-i-already-started-rebase\n\n2. https://stackoverflow.com/questions/12522565/how-can-i-combine-two-commits-into-one-commit\n\n**注意事项**：如果你正在使用远程仓库，且这个仓库的贡献者不止你一个人，那么在主分支上进行下列操作可能会使他人的文件丢失。您最好==在自己的分支上进行变基==，或者在操作前与他人充分沟通。\n\n**步骤**：\n\n1. 使用`git log --pretty=oneline`查看你需要合并的commits:\n\n```bash\n$ git log --pretty=oneline\na931ac7c808e2471b22b5bd20f0cad046b1c5d0d c\nb76d157d507e819d7511132bdb5a80dd421d854f b\ndf239176e1a2ffac927d8b496ea00d5488481db5 a\n```\n\n假设提交的先后顺序是 a --> b --> c，你需要合并 c 和 b\n\n2. 使用`git rebase -i HEAD~2` （<a href=\"#chatGPT expaination on the command\">chatGPT expaination on the command</a>）,这个命令会打开一个文本文件，让你查看最近的两条提交记录，注意和`git log`输出不同，**较新的提交记录在下面，比较旧的在上面。**\n\n```bash\npick b76d157 b\npick a931ac7 c\n\n# Rebase df23917..a931ac7 onto df23917\n#\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n# However, if you remove everything, the rebase will be aborted.\n#\n```\n\n3. 把**较新的commit**前面的`pick`改成`squash`，然后保存并退出 :\n\n```bash\npick   b76d157 b\nsquash a931ac7 c\n```\n\n4. 之后你会得到提示：\n\n```bash\n# This is a combination of 2 commits.\n# The first commit's message is:\n\nb\n\n# This is the 2nd commit message:\n\nc\n```\n\n5. 再次用`git log --pretty=oneline`查看，就会看到：\n\n```bash\n$ git log --pretty=oneline\n18fd73d3ce748f2a58d1b566c03dd9dafe0b6b4f b and c\ndf239176e1a2ffac927d8b496ea00d5488481db5 a\n```\n\n大功告成！\n\n如果你对commit信息不满意，那么可以自行<a href=\"#change-commit-messages\">修改commit信息</a>。\n\n6. 如果你在推送到远程仓库时失败了，尝试使用`git push -f` 来进行推送。**请确保你的这步操作不会影响到正在使用同一仓库的其他人！！！**\n\n\n\n### chatGPT expaination on the command\n\n> The command `git rebase -i HEAD~6` starts an interactive rebase process that allows you to interactively edit the last six commits on the current branch.\n>\n> More specifically, the `-i` flag tells Git to start an interactive rebase, while `HEAD~6` specifies the parent of the current commit. In this case, the parent of the current commit is six commits ago.\n>\n> By running this command, Git will open an interactive file in your default text editor, showing you the last six commits on the branch. You can then edit the file to choose which commits to keep, squash, or edit, among other options. Once you've made your changes and saved the file, Git will apply your changes and rewrite the Git history of the branch with your new commit history.\n>\n> Note that the `git rebase` command should be used with caution, especially when rewriting Git history. If you're working with a shared repository or collaborating with others, you should communicate with them before rewriting the Git history of a branch.\n\n# tag标签\n\n- 分离头指针：\n\n```bash\ngit switch <commit id> --detach   #commit id可以只写前几位\n```\n\n把头指针移动到早期创建的某个节点上。注意：==此时只能预览，不可以修改和提交代码。==\n\n\n\n- 如果要在早期的节点上进行修改，请在该早期节点上==创建新分支==：\n\n```bash\ngit switch -c <new branch name> <commit id>\n```\n\n\n\n但是，如果版本很多，找到某个特定的节点很困难。使用**标签**来给特定的节点做记号。\n\n- 标签\n\n```bash\ngit tag #显示当前节点的所有标签\ngit tag <tag name> #给当前节点添加一个标签 比如 v1.0\ngit tag <tag name> <cmt id> #给某个节点添加标签\n\n#使用标签来操作：\ngit push <remote> <tag name> #给远程仓库的版本加标签(推送本地标签到远程仓库)\ngit push <remote> --tags #推送所有本地标签\ngit -d <tag name> #删除本地标签\ngit push <remote> --delete <tagname> #删除远程仓库的标签\n```\n\n之后，我们就可以通过标签来快速之前的定位节点，创建新分支了。\n\n```bash\ngit switch -c <tag name>\n```\n\n\n\n# 远程仓库(remote)\n\n- GitHub\n- Gitee\n\n上传到github：\n\n```bash\ngit remote add origin https://github.com/lilichao/git-demo.git\n# git remote add <remote name> <url>\n\ngit branch -M main\n# 修改分支的名字的为main\n\ngit push -u origin main\n# git push 将代码上传服务器上\n```\n\n\n\n## 远程库的操作的命令\n\n```bash\ngit remote # 列出当前的关联的远程库\ngit remote add <远程库名> <url> # 关联远程仓库\ngit remote remove <远程库名>  # 删除远程库\n\ngit push -u <远程库名> <分支名> # 向远程库推送代码，并和当前分支关联\ngit push <远程库> <本地分支>:<远程分支> #推送到指定的远程分支\n\ngit clone <url> # 从远程库下载代码\ngit clone <url> <new filename># 从远程库下载代码,并重命名\n\ngit push # 如果本地的版本低于远程库，push默认是推不上去\ngit fetch # 要想推送成功，必须先确保本地库和远程库的版本一致，fetch它会从远程仓库下载所有代码，但是它不会将代码和当前分支自动合并\n\t\t # 使用fetch拉取代码后，必须要手动对代码进行合并\ngit merge origin/master #手动合并\ngit pull  # 从服务器上拉取代码并自动合并 \n```\n\n==注意：==\n\n==1. 推送代码之前，一定要先从远程库中拉取最新的代码==\n\n==2. 写自己的代码前，一定要创建新分支==\n\n\n\n## origin/main/master\n\n来源：https://blog.csdn.net/reykou/article/details/104866348\n\n1. GIT 初始化：本地默认分支叫 master、服务器默认名为 origin。本地分支 master 同步到服务器上、服务器节点变成 orgin/master\n2. 本地创建分支名为 branch，本地分支 branch 同步到服务器上、服务器节点变成 orgin/branch\n3. 更新本地分支 master，用本地分支 master 更新服务器节点 orgin/master\n\n\n\n## git代理的设置\n\n远程库连接很缓慢，那么，我们可以通过配置代理来解决这个问题。\n\n首先查看你的代理软件的相关设置，搞清楚你代理使用的本地socks端口：\n\n<img src=\"..\\img\\gitPics\\socksPort.png\" style=\"zoom:100%;\" />\n\n```bash\ngit config --global https.proxy http://127.0.0.1:10808  #设置为你自己的端口，比如我的是10808\n\ngit config --global https.proxy https://127.0.0.1:10808\n\ngit config --global --unset http.proxy\n\ngit config --global --unset https.proxy\n```\n\n参考：https://gist.github.com/laispace/666dd7b27e9116faece6\n\n\n\n## 远程库解决push授权问题\n\n配置完代理，可能会引发如下问题：\n\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b/AceMyFile (master)\n$ git push origin master\nfatal: NotSupportedException encountered.\n   The ServicePointManager does not support proxies with the socks5h scheme.\nerror: unable to read askpass response from 'E:/git/Git/mingw64/libexec/git-core/git-gui--askpass'\nUsername for 'https://github.com': xxxx\nremote: Support for password authentication was removed on August 13, 2021.\nremote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.\nfatal: Authentication failed for 'https://github.com/xxxx/xxxx.git/'\n\n```\n\n如果用VSCode推送好像可以绕开这个问题。\n\n但是，如果使用命令行来推送：\n\n```bash\n$ git push origin master\nfatal: NotSupportedException encountered.\n   The ServicePointManager does not support proxies with the socks5h scheme.\nerror: unable to read askpass response from 'E:/apps/git/Git/mingw64/libexec/git-core/git-gui--askpass'\nremote: Support for password authentication was removed on August 13, 2021.\nremote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.\nfatal: Authentication failed for 'https://github.com/0xtopus/CS61B-repo.git/'\n```\n\n发现2021年8月13日之后URL推送的方法就已经不支持了。\n\n于是，我们可以采用ssh的方法来推送。\n\n### ssh方法\n\n参考1：https://www.cnblogs.com/yuqiliu/p/12551258.html\n\n参考2：https://blog.csdn.net/lonyw/article/details/75392410\n\n\n\n1. 先查看自己本地设置的邮箱：\n\n   ```bash\n   git config –global user.email\n   ```\n\n2. 然后输入：\n\n   ```bash\n   ssh-keygen -t rsa -C \"你设置的邮箱\"\n   ```\n\n   代码参数含义：\n\n   -t 指定密钥类型，默认是 rsa ，可以省略。\n   -C 设置注释文字，比如邮箱。\n   -f 指定密钥文件存储文件名。\n\n   然后会输出一些提示让你操作。连续按三个回车，全部默认即可。\n\n   （三个操作分别是：选择使用默认路径存放ssh秘钥（`/c/Users/Administrator/.ssh/id_rsa`），不使用`paaphrase`私钥，确认私钥。\n\n   关于私钥的作用，一般可以不要：\n\n   > What is passphrase in git?\n   >\n   > With SSH keys, if someone gains access to your computer, the attacker can gain access to every system that uses that key. **To add an extra layer of security, you can add a passphrase to your SSH key**. To avoid entering the passphrase every time you connect, you can securely save your passphrase in the SSH agent. \n   >\n   > source: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/working-with-ssh-key-passphrases\n\n   完成以上操作，你会看到类似下面的输出：\n\n   ```bash\n   Generating public/private rsa key pair.\n   Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):\n   Created directory '/c/Users/Administrator/.ssh'.\n   Enter passphrase (empty for no passphrase):\n   Enter same passphrase again:\n   Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa\n   Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub\n   The key fingerprint is:\n   SHA256:lhiwE3T6NRzcttxFPBj5LDpy0CtmnYG/55NqOuRK3Tk gsy@gsy123mailbox.com\n   The key's randomart image is:\n   +---[RSA 3072]----+\n   |   .+ ....  .*.  |\n   |     * ...o o +  |\n   |    + . += o + . |\n   |     o +oo= o o  |\n   |      o S+ = .   |\n   |       o*.O.     |\n   |      .=.+Eo .   |\n   |     .  o o.+    |\n   |      ...+.+..   |\n   +----[SHA256]-----+\n   \n   ```\n\n3. 然后输入：\n\n   ```bash\n   ssh -T git@github.com\n   ```\n\n   得到输出：\n\n   ```bash\n   The authenticity of host 'github.com (140.82.112.4)' can't be established.\n   ECDSA key fingerprint is SHA256:xxxxxx.\n   Are you sure you want to continue connecting (yes/no/[fingerprint])? \n   ```\n\n   输入yes，回车继续，看到如下输出即成功：\n\n   ```bash\n   Warning: Permanently added 'github.com,140.82.112.4' (ECDSA) to the list of known hosts.\n   Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access.\n   ```\n\n   \n\n4. 接下来可以通过`git remote -v`查看远程主机的状态，看到：\n\n   ```bash\n   origin  https://github.com/xxxx.git (fetch)\n   origin  https://github.com/xxxx.git (push)\n   ```\n\n   说明还是通过URL方式访问，接下来我们来修改为ssh方式。\n\n5. 打开你的github仓库页面：\n\n   <img src=\"..\\img\\gitPics\\ssh.png\" style=\"zoom:75%;\" />\n\n6.  输入下列命令：\n\n   ```bash\n   git remote set-url origin git@github.com:xxxx.git\n   ```\n\n   `git@github.com:xxxx.git`就是你刚刚复制的内容。\n\n   再次`git remote -v`\n\n   看到：\n\n   ```bash\n   origin  git@github.com:xxxx.git (fetch)\n   origin  git@github.com:xxxx.git (push)\n   ```\n\n   就大功告成啦！\n\n   现在就可以直接push了：\n\n   ```bash\n    git push origin master\n   ```\n\n   \n\n\n\n\n\n\n\n## GitHub添加/删除关联的远程仓库\n\n参考：https://blog.csdn.net/ltstud/article/details/79935001\n\n```bash\ngit remote add <远程仓库名> <本地库名>\ngit remote rm <远程仓库名> \n```\n\n\n\n# 换邮箱后的配置\n\n比如ssh什么的，参见：https://gist.github.com/Heron-Wang/1f608c4c93065d1ebd67f7b29e3be791\n\n\n\n# gitignore\n\n- 默认情况下，git会监视项目里所有的文件。但是有时候，不是所有的文件都需要被git监视。\n- 使用 *gitignore* 来让git忽略它们\n- 在项目目录里新建一个 `.gitignore` 文件，把要忽略的文件名输入进去\n\n```\n#注释\nnode_modules\nyarn.lock\n*.log\n```\n\n\n\n## git ignore 配置\n\n1. 使用`!<filename>`来使git不忽略某个文件。比如你需要git不忽略某个叫做`MyFile`的文件夹下的所有文件，在`.gitignore`里你可以这样写：\n\n   ```txt\n   !MyFile/*\n   ```\n\n   \n\n2. \n\n\n\n# 查看git配置\n\n```bash\ngit config <配置名> #查看某个配置情况\n```\n\n更多配置：https://www.atlassian.com/zh/git/tutorials/setting-up-a-repository/git-config\n\n\n\n# GitHub 只添加已追踪的文件\n\n```bash\ngit add -u\n```\n\nref: https://www.google.com/search?q=how+to+add+tracked+files+only+in+git&oq=how+to+add+tracked+files+only+in&aqs=chrome.1.69i57j33i10i160l3.16226j0j9&sourceid=chrome&ie=UTF-8\n\n使用前：\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   lab2/DebugPractice/DebugExercise1.java\n        modified:   lab2/DebugPractice/DebugExercise2.java\n        modified:   lab2/Intlist/IntList.java\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        lab2/.idea/\n        lab2setup/.idea/\n        lab2setup/out/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n使用：\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git add -u\n```\n\n使用后：\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        modified:   lab2/DebugPractice/DebugExercise1.java\n        modified:   lab2/DebugPractice/DebugExercise2.java\n        modified:   lab2/Intlist/IntList.java\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        lab2/.idea/\n        lab2setup/.idea/\n        lab2setup/out/\n\n```\n\n\n\n# Github ICU\n\n远程仓库和本地仓库出现较大混乱时，可以这样恢复到希望回到的之前的某个commit版本。\n\n首先，进入你的本地仓库，使用`git log`命令找到你希望退回的**commit版本号**，然后使用：\n\n```bash\ngit reset --hard <commit>\n```\n\n回到你希望的commit版本。但是，在使用之前，==你最好将文件进行备份==，以免reset到错误的版本后丢失数据。\n\n你也可以使用`git reflog`来查看之前的操作，并且可以通过`git reflog`里提供的commit版本号来再次使用`reset --hard`命令回溯到操作前所在的commit版本（可以作为reset错误后的后悔药！）\n\n然后，对远程仓库使用强行同步更新：\n\n```bash\ngit push -f \n```\n\n[^参考1]:  https://stackoverflow.com/questions/42860234/how-to-undo-a-merge-in-github，Stack Overflow的相关回答。\n[^参考2]:  https://initialcommit.com/blog/git-reset，对reset的详细讲解\n[^参考3]:https://stackoverflow.com/questions/495345/how-to-remove-selected-commit-log-entries-from-a-git-repository-while-keeping-th，Stack Overflow.\n[^参考4]: https://stackoverflow.com/questions/4114095/how-do-i-revert-a-git-repository-to-a-previous-commit，Stack Overflow上的一个比较详细的高赞回答，不过我没细看...\n[^参考5]: https://stackoverflow.com/questions/29042783/how-can-i-delete-all-commits-before-a-given-date-in-git-history，Stack Overflow：how can I delete all commits before a given date in git history.\n\n\n\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git log\ncommit cca2edf5fbf99d5295cca7c0c56c807f0e2194ab (HEAD -> master, origin/master, origin/HEAD)\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 11 17:00:26 2023 +0800\n\n    reset files\n\ncommit ad9c8610ec1d326fa88c7a8088ae53b4fe6fff5c\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Fri Feb 10 11:06:37 2023 +0800\n\n    fix the bug of IntList.java*\n\ncommit c0ae005a84005d9f528673b36ca4507386ac711c\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Thu Feb 9 23:02:06 2023 +0800\n\n    add IntList.java with a small bug which would count one less size of the IntList and also modify my note a bit\n\ncommit 3bae4aa49e997c62db531f53c6427ea510f90942\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Wed Feb 8 22:26:27 2023 +0800\n\n    add .gitignore, SumArg.java and modify my note\n\ncommit 4f461e2ca33d4d7e878011305dd401d91209f13e\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 4 23:26:25 2023 +0800\n\n    create new README file and tweak my first week  java note\n\ncommit 14f93eae87f460eebf10617cbb650d2ca0af8c57\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 4 23:20:55 2023 +0800\n\n    finish the first week task\n\ncommit 5551fe36d65a915e35b7af01beb615cf596d9902\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 4 21:47:51 2023 +0800\n\n    commit first week's stuff\n\n\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git reflog\ncca2edf (HEAD -> master, origin/master, origin/HEAD) HEAD@{0}: commit: reset files\nad9c861 HEAD@{1}: reset: moving to ad9c8610\na09fb44 HEAD@{2}: checkout: moving from master to master\na09fb44 HEAD@{3}: pull --allow-unrelated-histories: Merge made by the 'recursive' strategy.\n7ef79fc HEAD@{4}: rebase finished: returning to refs/heads/master\n7ef79fc HEAD@{5}: rebase: delete all skeleton files\n4f0a62f HEAD@{6}: rebase: delete all skeleton file and try to set up again\n0515c34 HEAD@{7}: rebase: lab1 ready to submit\na3610f2 HEAD@{8}: rebase: add all files from official repo of cs61b\nad9c861 HEAD@{9}: rebase: fix the bug of IntList.java*\nc0ae005 HEAD@{10}: rebase: add IntList.java with a small bug which would count one less size of the IntList and also modify my note a bit\n3bae4aa HEAD@{11}: rebase: add .gitignore, SumArg.java and modify my note\n4f461e2 HEAD@{12}: pull --rebase --allow-unrelated-histories skeleton master: create new README file and tweak my first week java note\n14f93ea HEAD@{13}: pull --rebase --allow-unrelated-histories skeleton master: finish the first week task\n5551fe3 HEAD@{14}: pull --rebase --allow-unrelated-histories skeleton master: commit first week's stuff\nfa6b0b8 (skeleton/master) HEAD@{15}: pull --rebase --allow-unrelated-histories skeleton master: checkout fa6b0b8a7f1d83bf1aa47b9182bce4cad238f14e\n\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git reset 7ef79fc\n\n```\n\n\n\n\n\n\n\n# GitHub大量删除和添加文档后批量暂存\n\n参考：https://blog.csdn.net/haohaibo031113/article/details/70821321\n\n```bash\ngit add -A  # GitHub大量删除和添加文档后批量暂存，也可以用 rm 命令来处理删除的文件\n```\n\n\n\n# GitHub重命名远程仓库\n\n```bash\ngit branch -M main #把当前master分支改名为main, 其中-M的意思是移动或者重命名当前分支\n```\n\n参考：https://juejin.cn/post/7051873701305778207\n\n\n\n# 小技巧\n\n1. 在命令行模式下，在要打开的目录里输入：\n\n```bash\ncode .\n```\n\n即可用vscode打开当前目录\n\n# 深入研究\n\nhttps://git-scm.com/book/en/v2\n\n# GitHub部署静态页面\n\n详见Hexo，Docusaurus等静态站点生成器的官网。\n\n\n\n# 复习\n\n在https://learngitbranching.js.org/?locale=zh_CN上练习git的基本操作命令，将复习的笔记记录在这里。\n\n## 分支\n\n```bash\ngit branch <new branch name>\n```\n\n- Switch to the new branch:\n\n```bash\ngit checkout <branch name>\n# or you can use:\ngit switch <branch name>\n```\n\n- Create new branch and switch to it immediately:\n\n```bash\ngit checkout -b <new branch name>\n```\n\n## Merge\n\n- To merge branches, say if there are two parallel branches `bugFix` and `main`, and we want to merge `bugFix` to `main`:\n\n```bash\ngit switch main\t# switch to the target branch\ngit merge bugFix # merge another branch to the target branch\n```\n\n## Rebase\n\nTo make commit history look more linear, we can \"rebase\" one of two parallel branches to another:\n\n```bash\ngit switch bugFix\ngit rebase main\n# now your \"bugFix\" branch is one node ahead of \"main\" branch\n```\n\n## HEAD Moving\n\nBy default, HEAD always points to the latest commit history. It is like: `HEAD -> main -> \"Hashtag of last commit\"`.\n\nTo move \"HEAD\" to point to a commit history at somewhere:\n\n```bash\ngit checkout <Hashtag of the commit history>\n```\n\nnow the HEAD is pointing to the given hashtag: `HEAD -> the given hashtag`\n\n- Relative branch movement:\n\n```bash\ngit branch -f <branch to move> <reference name>~<num>\n# for example:\ngit branch -f main HEAD~\t\t# move main to the previous node of HEAD\ngit branch -f bugFix <Hashtag>\t# move bugFix to the specified hashtag\ngit branch -f main bugFix~2 \t# move main to the second previous node of bugFix\n```\n\n- Atn alternative way to move HEAD\n\n```bash\n# All these three move HEAD according to the relative position of target\ngit checkout main^\ngit checkout <hashtag>^\ngit checkout HEAD~\n```\n\n## Undo changes\n\n- `git revert`: create a new commit which is identical to the given one.\n\n  <span style=\"font-weight:bold;color:red\">Recommend when there's something need to be undone in remote repo</span>\n\n```bash\ngit revert HEAD\t# create a new commit the same as the previous one to the current commit.\n```\n\n- `git reset`: move the commit backward(The change of undone commit is still alive but in the state of not added.) \n\n  <span style=\"font-weight:bold;color:red\">Recommend to edit local commit history only!</span>\n\n```bash\ngit reset HEAD~1\t# undo the latest commit\n```\n\n\n\n"}]