[{"title":"Interactive React","url":"/Interactive-React/","content":"\n# Interactive React\n\n这里讨论任何使用React Library构建网页互动，包括如何处理事件、通过钩子函数（hooks）来给组件存储动态数据，以及介绍如何实现某些特定的互动操作（比如使用表格和下载数据）。\n\n## 事件处理\n\nReact支持多种多样的用户互动操作，就像DOM和JQuery一样：注册一个事件监听器并提供特定的回调函数在某个事件发生的时候执行。\n\n在React中，你在**组件中返回的JSX元素里**使用 `on` + `特定事件名` 的组合来作为属性名称，而给该属性值赋值为特定回调函数来绑定事件。\n\n该属性想要使用小驼峰命名法（camelCase），比如 `onClick` 或者 `onMouseOver` 等等。如果你想查看所有支持的事件处理属性名，见： [synthetic events](https://reactjs.org/docs/events.html#supported-events).\n\n```jsx\n//A component representing a button that logs a message when clicked\nfunction MyButton() {\n    //A function to call when clicked. The name is conventional, but arbitrary.\n    //The callback will be passed the DOM event (just like with DOM callbacks)\n    const handleClick = (event) => {\n        console.log(\"clicky, clicky\");\n    }\n    \n        //make a button with an `onClick` attribute!\n    //this \"registers\" the listener and sets the callback\n    return <button onClick={handleClick}>Click me!</button>\n}\n```\n\n一般来说，回调函数在组件内定义，成为“函数中的函数”（因为组件也是函数！），所以按照惯例我们会将嵌套的函数用箭头函数定义。\n\nDOM会为返回的 `<button>` 元素绑定事件。\n\n你也可以在返回的JSX里面的元素里面定义回调函数，但易读性差，不推荐。\n\n```jsx\nfunction MyButton() {\n    return <button onClick={(evt) => console.log(\"clicky clicky\")}/>\n}\n```\n\n### 别给组件指定事件属性！\n\n**注意：是在React的元素（即HTML元素）里注册事件！不可以给React组件注册事件！！！**如果你在React组件里尝试指定事件处理属性，那么实际上你只是给组件绑定了一个Props！\n\n> If you tried to specify a `<MyButton onClick={callback}>`, you would be passing a *prop* that just happened to be called `onClick`, but otherwise has no special meaning!\n\n\n\n> 尽管功能类似，但React的事件处理属性和HTML的事件处理器不一样，即：`onClick` ≠ `onclick` ！React属性只适用于React event system。\n\n\n\n## State和Hook\n\n为了使得React的组件能根据用户的动作而实时改变，我们需要追踪组件的状态（State），这就需要用到用到*state*，注意，只有会不停改变状态的数据才能被声明为state，如果变量是**一成不变**的，或者**并未在DOM中直接或间接地被渲染**，那就不是state！\n\n当state发生变化的时候，组件就会根据state的变化被重新渲染！\n\n对于函数组件，state可以用State Hook来添加到组件中。\n\n> Hooks were introduced with React v16.8 (October 2018), and thus are the “new” current way of handling state. For details on older techniques (which require using *class components*), see [*State in Class Components*](https://info340.github.io/class-components.html#state-in-class-components).\n\n> Fun fact: hooks are basically an example of [*mixins*](https://en.wikipedia.org/wiki/Mixin), which are an object-oriented technique for including/injecting data or behavior in a class without needing to inherit that behavior from a parent class.\n\nState Hook实际上是React提供的一个函数：`useState()` ，使用 named export 来从React Library里将其引入：\n\n```js\n//import the state hook function\nimport React, { useState } from 'react';\n```\n\n然后，一般在函数组件的最上方使用 `useState()` 函数来创建state，这样后面的代码就可以使用创建的state变量了：\n\n```jsx\nfunction CountingButton() {\n    //Define a `count` state variable, initially 0\n    const [count, setCount] = useState(0);\n\n    //an event handling callback\n    const handleClick = (event) => {\n        setCount(count+1); //update the state to be a new value\n    }\n\n    return (\n        { /* a button with the event handler that displays the state variable */}\n        <button onClick={handleClick}>You clicked me {count} times</button>\n    );\n}\n```\n\n在组件被渲染/重新渲染的时候，state变量会被追踪和储存，你可以将state变量当成一个**实例变量**，实际上它被存储在一个对象实例变量中（object instance variable）。\n\n函数 `useState` 的参数是state变量的初始值，在上面的代码中，`count` 被初始化为0.\n\n函数 `useState` 的返回值是一个有两个元素的数组：第一个是当前的state变量的值，第二个是用来改变该值的set函数，你可以使用“array destructuring”来分别将这两个值赋给不同的变量。\n\n你可以将返回值命名为啥都行，比如：\n\n```js\nconst [countVariable, functionToUpdateCount] = useState(0)\n```\n\n> Because the function is a “setter” it’s usually named as such (`setVARIABLE`), but this is not required. It’s just a function; you can name it whatever you want.\n\n\n\n### 更新state\n\n不可以直接修改state变量！这也是为何state变量被声明为 `const` 的原因。\n\n请使用set函数来更新。当set函数被调用的时候，不仅仅state变量被更新，其对应的组件也会被重新渲染。\n\nReact会**异步([*asynchronous*](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous))**地将一打state变量的更新打包，然后用一个请求一次性将页面中需要更新的组件重新渲染完成，这样，既减少了重新渲染的次数，又保证了页面刷新的高效性。\n\n```jsx\n//An Component with a callback that doesn't handle asynchronous state changes\nfunction CounterWithError(props) {\n    const [count, setCount] = useState(3) //initial value of 3\n\n    const handleClick = (event) => {\n        setCount(4); //change `count` to 4\n        console.log(count); //will output \"3\"; state has not changed yet!\n    }\n}\n```\n\n> this example, because `setCount()` is asynchronous, you can’t immediately access the updated state variable after calling the function. You instead need to wait for the component to “rerender”—when the component’s DOM is regenerated, it will use the updated value. If you want to see that value, log it out right before you return the DOM (not inside of the click event handler).\n\n在重新渲染的时候，你的函数组件会被再次重新调用，这意味着所有函数组件里的逻辑都会被重新执行一遍！\n\n> **警告：**永远不要在函数组件内之间调用set函数，否则会触发**无限循环的递归调用**！\n\n在函数组件里的回调函数里，你可以为一个组件添加多个state变量：\n\n```jsx\n//Example from React documentation\nfunction ExampleWithManyStates() {\n    //Declare multiple state variables!\n    const [age, setAge] = useState(42);\n    const [fruit, setFruit] = useState('banana');\n    const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n}\n```\n\n尽管可以把一堆state值存放在一个数组或者对象里，上面这种做法更加简洁，而且在只有少部分数据需要更新时无需更新整个数组或对象，因此十分推荐！\n\n同样，如果你要使用set函数更新一个类型为数组或对象的state变量，请**创建一个全新的变量**而不是将原state变量的成员该值后传递给set函数，因为React不会检查原变量的成员，这是为了保证数据的不变性：\n\n- 错误的示范：\n\n```js\nfunction TodoListWithError() {\n    //a state value that is an array of objects\n    const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n\n    const handleClick = (event) => {\n        todos[0].text = \"Fix bugs\"; //modify the object but don't make a new one\n        setTodos(todos) //This won't work!\n    }\n}\n```\n\n- 正确的示范：\n\n```jsx\nfunction TodoList() {\n    //a state value that is an array of objects\n    const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n\n    const handleClick = (event) => {\n        //create a copy of the array using the `map()` function\n        const todosCopy = todos.map((todoObject, index) => {\n            if(index == 0) { //transform objects if needed\n                todoObject.text = \"Fix bugs\"\n            }\n            return todoObject; //return object to go into new array\n        })\n        setTodos(todosCopy) //This works!\n    }\n}\n```\n\n一般的，可以使用 `.map()` 来创建新数组，使用 spread operator 或 [`Object.assign()` function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 来创建新对象。\n\n```js\n//an original object\nconst original = {a: 1, b: 2};\n\n//Create a copy, taking the property of `original` and assigning them into\n//a fresh object\nconst copy = { ...original } //using the spread operator\nconsole.log(copy) //{a: 1, b: 2}\nconsole.log(copy == original) //false, different objects\n```\n\n### State vs. Props\n\nState是会随着与用户交互而改变的数据，而Props是父组件传入的数据，你可以将props的值赋给一个State变量，但props的值是不变的，只是恰好作为state变量的初值罢了。\n\n> `props` are for information that doesn’t change from the Component’s perspective, including “initial” data. `state` is for information that will change, usually due to user interaction.\n\n```jsx\n//A component representing a count\nfunction Counter(props) {\n    const [count, setCount] = useState(props.startAt)\n}\n\nlet counter = <Counter startAt={5} />\n```\n\n\n\n出于对性能的考虑，应当尽可能地使state变量的数量保持最小，如果你不确定某个值是否应该为state，考虑以下三个问题：\n\n1. 如果这个值是props传递进组件的，那么大概率它不应该是一个state；\n2. 如果该值不会发生变化，那么它不是state；\n3. 如果这个值是基于另一个props或state变量，那么它不是state。\n\n### State的提升\n\n即Lifting up state，由于父组件可以轻松地将state变量作为props传递给子组件，而state变量在兄弟组件之间难以传递，因此，对于某些情境下需要互通state数据的兄弟组件来说（比如一个搜索框和搜索结果栏），我们会把这些state放到它们**层级最低的共同的父组件**中，在父组件里定义一个可以修改该state的回调函数作为props传递给子组件，让子组件发生交互的时候调用该回调函数触发父组件的重新渲染。\n\n由于父组件重新渲染的时候也会顺便生成新的子组件，这样就实现了父组件和兄弟组件和它自己的重渲染。\n\n```jsx\n<App>\n  <SearchForm /> {/* has the data */}\n  <ResultsList /> {/* needs the data */}\n</App>\n```\n\n下面是一个 `VotingApp` 的例子，通过计算哪个按钮被点击的次数最多而显示结果（`winner`）。\n\n```jsx\nfunction VotingApp(props) {\n    //initialize the state counts, one for each color\n    //using a single state value so that there is only one \"update\" function\n    const [counts, setCounts] = useState({red: 0, blue: 0})\n\n    //a function to update the state\n    //expects a \"color\" for which button was clicked\n    const handleCount = function(color) {\n        console.log(color + \" got a vote!\");\n\n        const newCounts = { ...counts } //make a duplicate of the object\n        newCounts[color]++; //update the local copy\n\n        setCounts(newCounts) //update the state with the changed copy\n    }\n\n    //render based on current state\n    let winner = \"tie\";\n    if(counts.red > counts.blue) winner = \"red\"\n    else if(counts.blue > counts.red) winner = \"blue\"\n    return (\n        <div>\n            <p>Current winner is: {winner}</p>\n            {/* Pass the callback to each button as a prop */}\n            <CandidateButton color=\"red\" winner={winner} callback={handleCount} />\n            <CandidateButton color=\"blue\" winner={winner} callback={handleCount} />\n        </div>\n    );\n}\n\nfunction CandidateButton(props) {\n    const handleClick = () => {\n        //On click, execute the given callback function (passing in own name)\n        props.callback(props.color)\n    }\n\n    //render based on current props\n    let label = \"I am not winning\";\n    if(props.winner === props.color)\n        label = \"I am winning!\"\n\n    return (\n        <button className={props.color} onClick={handleClick}>\n            {label}\n        </button>\n    );\n}\n```\n\n流程图如下：\n\n```mermaid\ngraph TD\n\tA(VotingApp) -- handleCount作为props传入 --> B(CandidateButton)\n\tB -- props.callback 触发重渲染 --> A\n```\n\n总结起来，制作互动React应用可以遵循下列步骤：\n\n1. 先使用组件建立一个静态的（没有任何互动的）版本；\n2. 找出所有需要随着互动而改变的变量，它们就是要存储在state里的变量；\n3. 将state变量存在需要它们的组件的最低层的共同祖先组件中；\n4. 将上述state作为props传入子组件；\n5. 将回调函数作为props传递给子组件；\n\n## 互动实例\n\n一些常用的React实例：\n\n### 表格\n\n我们常常要创建一些表格（[forms](https://reactjs.org/docs/forms.html)），这样用户就可以填写并提交一些我们想要的信息。\t\n\n在HTML中，我们用 `<input>` 元素来追踪用户在表格中输入的值，这些值由属性 `value` 来追踪：\n\n```js\n//Select the <input type=\"text\"> element\nlet textInput = document.querySelector('input[type=\"text\"]');\n\n//Event that occurs whenever the input is changed\ntextInput.addEventListener('change', (event) => {\n    let input = event.target;\n    console.log(input.value); //access that elements \"state\"\n});\n```\n\n有时候我们会需要将用户的输入作为一个AJAX请求发送出去，或者你只是想验证一下用户输入的密码是否符合安全规范。但在React中使用input往往会引起一些问题。因此推荐的方法是使用 [**controlled Components**](https://reactjs.org/docs/forms.html#controlled-components) 。\n\n这种方法就像是用React组件读取用户在 `<input>` 元素中输入的内容，即通过事件处理 `onChange` 触发回调函数拿到input里的内容，把用户输入的内容赋给的组件中的 `<input>` 的 `value` 属性和定义的state变量（在下面为 `inputValue`），通过state变量的改变触发重渲染。\n\n> It’s like React is snatching the data from the `<input>` and then claiming credit for it.\n\n```jsx\nfunction MyInput(props) {\n    const [inputValue, setInputValue] = useState('')//initialize as empty string\n\n    //respond to input changes\n    const handleChange = (event) => {\n        //get the value that the <input> now has\n        let newValue = event.target.value\n\n        //update the state to use that new value, rendering the component\n        setInputValue(newValue);\n    }\n\n    return (\n        <div>\n            {/* The input will be rendered with the React-controlled value */}\n            <input type=\"text\" onChange={handleChange} value={inputValue} />\n            <p>You typed: {inputValue}</p>\n        </div>\n    );\n}\n```\n\n**Tips：**\n\n- 当然，你也可以用一个controlled form渲染多个 `<input>` 标签，这样你就可以在同一个组件里用不同的state变量追踪它们的输入值了。这在验证“请重新输入密码”栏里的密码是否和之前输入的密码一致时非常有用！\n- 在React中维护表格的健壮性其实是一件很困难的事！ (especially when compared to other frameworks such as Angular). 你可以使用外部的库，比如 [Formik](https://jaredpalmer.com/formik) 来帮助你开发表格并避开一些很难考虑到的极端情况。\n\n### 用AJAX获取数据\n\n生命周期回调函数（lifecycle callback functions）最常见的用途之一是异步访问数据，例如通过 AJAX 请求获取数据（见第 [18 章](https://info340.github.io/ajax.html#ajax)）。本节将详细介绍如何在 React 框架中异步加载数据。\n\n首先， React 代码是使用 Webpack 转译的。因此，某些 API（包括 `fetch()`）并不像现代浏览器那样 \"内置 \"于 React。正如第 18 章所述，为了支持这些 \"其他 \"浏览器，您需要加载一个 *polyfill*。您可以在 React 中安装 whatwg-fetch 库，然后在 React 代码中导入该 polyfill：\n\n```bash\n# On command line, install the polyfill\nnpm install whatwg-fetch\n```\n\n```js\n//In your JavaScript, import the polyfill (loading it \"globally\")\n//This will make the `fetch()` function available\nimport 'whatwg-fetch';\n```\n\n记住，`fetch()` 是异步下载数据的。因此，如果要下载一些数据来显示，可能需要一段时间才能到达。我们不希望 React  \"等待 \"数据（因为 React 的设计宗旨就是快速）。因此，最好的做法是发送 `fetch()` 请求获取数据，然后在数据下载完成后调用 set state 函数用下载的数据更新组件。(可以将其数据状态初始化为的 \"空数组\"）。\n\n在 React 中，从互联网获取数据被认为是一种[**side effect**](https://en.wikipedia.org/wiki/Side_effect_(computer_science))。函数组件最好只做一件事：返回将在屏幕上呈现的 DOM。但下载数据会修改该框架之外的东西，因为它会修改网络状态/信息，甚至远程服务器的状态！因此，直接在组件函数内部调用 fetch() 是糟糕的编程风格，并可能在组件渲染时引发问题和错误。例如，如果获取的数据返回太快或太慢，尝试设置还未绑定到DOM的状态变量（从而重新渲染）会导致 React 崩溃。如果state更新了并重新渲染了组件，再次调用组件函数将导致组件再次下载数据，从而可能造成无限循环！\n\n因此，你可以使用 [**effect hook**](https://reactjs.org/docs/hooks-effect.html),  即 React 函数 **`useEffect()`**。这可让您让钩子和组件的生命周期挂钩，指定组件完成渲染后应运行的某些代码（函数）。任何会产生副作用的代码（例如下载数据、在 React 渲染之外操作 DOM 或设置对数据源的订阅）都应通过effect hook来运行。\n\n```jsx\n//import the hooks used\nimport React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n    //store the data in a state variable, initialized as an empty array\n    const [data, setData] = useState([]);\n\n    //specify the effect hook function\n    useEffect(() => {\n        fetch(dataUri) //send AJAX request\n          .then((res) => res.json())\n          .then((data) => {\n            let processedData = data.filter(...).map(...) //do desired processing\n            setData(processedData) //change the state and re-render\n          })\n    }, []) //empty array is the second argument to the `useEffect()` function.\n           //It says to only run this effect on first render\n\n    //Map the data values into DOM elements\n    //Note that this works even before data is loaded (when the array is empty!)\n    let dataItems = data.map((item) => {\n        return <li key={item.id}>{item.value}</li>; //return DOM version of datum\n    })\n\n    //render the data items (e.g., as a list)\n    return <ul>{dataItems}</ul>;\n  }\n}\n```\n\n `useEffect()` 函数需要两个参数：\n\n- 一个回调函数作参数，该函数将在组件渲染后运行。关于如何使用该函数，请注意以下几点：\n  - 与一样，必须 `import` 效果钩子函数 `useEffect`（作为named import）。\n  - `useEffect()` 函数将组件渲染后运行的回调函数一般声明为一个箭头函数，注意，**该回调函数不需要参数。**\n  - 在 `useEffect()` 回调函数内部执行正常的 `fetch()` 调用。请注意，下载的数据会通过调用 set state 函数（本例中名为 `setData()`）分配给组件的状态变量。\n- 第二个参数是一个数组，表示当数组内指定的状态发生变化时才重新渲染组件（如果是空数组，那么表示仅在第一次渲染组件的时候运行 effect函数）。\n\n> By default, the effect callback will be executed after *each* time the component renders. That means that if the component needed to re-render (because a prop changed for example), then the data would be downloaded a second time! To avoid this, you can pass the `useEffect()` function an optional second argument. This argument should be an array of values that the effect “depends on”—the effect will only be re-run if one of these variables changes between renders:\n\n虽然理论上组件要渲染两次（一次没有数据，另一次有数据），但 React 可以将这些请求处理打包在一起处理，如果数据下载速度足够快，用户就不会注意到。“This is also a good reason to [conditionally](https://reactjs.org/docs/conditional-rendering.html) include DOM elements like spinners when rendering data.”有条件的包含DOM元素？\n\n`useEffect()` 函数无需返回任何值。事实上，它能返回的唯一值是一个 \"清理 \"回调函数，每当组件从 DOM 中移除时，React 都会运行该函数：\n\n```js\nuseEffect(() => {\n    //...\n    return function cleanup() { //function name is arbitrary\n        console.log(\"component has been removed!\")\n    }\n})\n```\n\n只有在需要cleanup的时候，比如：subscribing to a data source or handling some user authentication behaviors. 普通的 `fetch()` 不需要cleanup。\n\n> React里有很多种hooks，更多信息请参考 [documentation](https://reactjs.org/docs/hooks-reference.html)。但一般来说，只有在遇到architectural problem (e.g., you have a lot of repeated code)你才需要使用hook — 否则： stick with the basic structure of props and state!.\n\n"},{"title":"React Note","url":"/React-Note/","content":"\n# React简介\n\n参考：[Introduction to React](https://info340.github.io/react.html)\n\nReact 是目前用于构建大型网络应用程序的最流行的 \"框架\"，其拥有数以百计的教程、视频和示例用于构建 React 应用程序。建议从[官方文档](https://reactjs.org/docs/getting-started.html)开始学习，尤其是[main concepts](https://reactjs.org/docs/hello-world.html)。本章或多或少沿用了 Facebooks 的 [Intro to React Tutorial](https://reactjs.org/tutorial/tutorial.html) 所使用的方法来进行叙述。\n\n## Get Started\n\n在使用React构建web应用程序的时候，需要用到大量开发工具，如果自行搭建开发环境非常费时费力。\n\n因此，我们可以使用 [**Create React App (CRA)**](https://create-react-app.dev/) 命令行工具历来搭建我们的React应用脚手架，它提供内置的的代码、测试以及部署方案。\n\n使用包管理器 `npm` 来调用CRA命令：\n\n```bash\n# Create a new React app project in a new `my-app` directory\n# This may take a minute...\nnpx create-react-app my-app --use-npm\n\n# Change into new project directory to run further commands\ncd my-app\n```\n\n- [npx](https://www.npmjs.com/package/npx) 命令与 `npm 5.2.0` 及更高版本一起安装，可用于（临时）安装和运行全局命令，一步到位。因此，与其使用 `npm install -g create-react-app`，不如直接使用 `npx`。\n\n- 参数 `--use-npm` 是可选的，但最好加上这句，因为这指定了使用 `npm` 而不是其他的包管理器。\n\n### 运行开发服务器\n\n创建 React 应用程序后，您可以使用 CRA 提供的脚本之一（启动脚本）自动启动开发网络服务器：\n\n```bash\n# Make sure you are in the project directory\ncd path/to/project\n\n# Run the development server script\nnpm start\n```\n\n上述命令会打开网络服务器，并自动打开一个新浏览器页面来展示渲染的页面！\n\n该网络服务器在代码发生任何改动的时候会自动执行下列操作：\n\n1. 将React代码 **transpile** 为纯 JavaScript；\n2. 将所有不同的modules打包(**bundle**) 到同一个文件里并将该文件注入HTML中 (adding the `<script>` tag for you)；\n3. 在浏览器界面里展示错误和警告：大部分错误和警告在console里展示，但严重的致命错误会直接显示在页面里 (e.g., syntax errors that crash the whole app)。如果你使用 [Chrome React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) 能进一步提供更多错误和调试信息；\n4. 只要源代码发生任何变动，它会帮你自动重载页面 (Though it is often good to manually refresh things when testing, just to make sure)；\n\n上述能力是由一个叫 [**webpack**](https://webpack.js.org/) 的工具提供的，CRA已经帮你配置好相关的设置了，所以你可以直接使用它。\n\n> **存在的问题：**\n>\n> In order to stop the server, hit `ctrl-c` on the command line.\n>\n> **Important**: As of 2018, there is an [issue](https://github.com/facebook/create-react-app/issues/932#issuecomment-433596579) with Create React App on Windows using Git Bash where hitting `ctrl-c` won’t actually stop the server—if you try to run it again, you’ll get an error about the port still being occupied. Current work-arounds are to use the Task Manager to end the `node` process, or to instead use the [Linux subsystem for Windows](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide).\n\n## 项目结构\n\n新建的React项目有以下结构：\n\n- `public/index.html`是页面的home page。其并不包含任何 CSS `<link>` 或 JavaScript `<script>` ，因为它们仅在构建页面的时候才被自动注入到HTML中。 项目的 CSS 和 JavaScript 都在 `src/` 文件夹下。 所有页面的内容都被定义为JavaScript的组件，即整个页面都是提供JavaScript来构建的。因此，除了改变诸如 `<title>` 和 favicon 等元数据以外， `index.html` 基本不需要作任何改动。\n\n  `index.html` 里几乎没有任何 HTML 内容，除了 `<head>`,  `<body>` 和一个 `<div id=\"root\">`。这是因为整个应用都将使用 React JavaScript 来构建，所有内容都会在稍后被注入 `#root` 元素内。\n\n  \n\n- `public/` 文件夹内存放所有不通过JavaScript加载但是是页面所需的文件 (i.e., they’re not “source code”)。比如，  `img/` 文件夹就位于此处，用来放置所有页面中所需的图片。 `public/` 文件夹是网页的“根目录”， 位于 `public/img/picture.jpg` 的图片在DOM中可以表示为： `img/picture.jpg`。详见： [Using the public folder](https://create-react-app.dev/docs/using-the-public-folder/) 。\n\n\n\n- `src/` 文件夹是放置 React app 源代码的地方。整个App由 `index.js` 脚本启动，并引入其他 `.js` 文件构建的JavaScript模组。一般而言，我们会用一个或多个modules(e.g., `App.js`, `AboutPage.js`)来实现组件, 这些组件稍后会被引入 `index.js` ；\n\n  - 默认模块 `reportWebVitals.js` 和 `setupTests.js` 分别用来支持测试和性能评估\n\n  \n\n- `src/index.css`  和 `src/App.css` 文件分别负责整个页面的CSS和单个组件的CSS。注意CSS文件在JavaScript文件里被引入 (with e.g., `import './index.css'` in the `src/index.js` file)。webpack知道如何处理引入的CSS文件，所以你不用费心再把它们link到HTML里。\n\n  如果你需要引入外部的样式，比如 Bootstrap 和 Font-Awesome，你可以在 `public/index.html` 里link它们，但最好的做法是将它们作为modules安装，并通过JavaScript来引入它们。具体做法可以参考文档： [*Adding Bootstrap*](https://facebook.github.io/create-react-app/docs/adding-bootstrap) 。\n\n  - 注意：所有CSS规则都是全局的，但为了保持项目结构清晰，CSS被打散到了不同的文件中。如果你不希望CSS被全局应用，见 [CSS in JS](https://info340.github.io/css-in-js.html#css-in-js)；\n\n- `README.md` 包含了 [User Guide](https://facebook.github.io/create-react-app/docs/documentation-intro) ，告诉你一些基本任务是如何实现的。在你想实现任何东西之前可以先看看这里是否有你需要的东西！\n\n> Overall, you’ll primarily be working with the `.js` and `.css` files found in the `src/` folder as you develop a React app.\n\n\n\n## JSX\n\nReact 的核心是一个简单的 DOM 创建和呈现库--它允许您声明新的 DOM 元素（例如，创建一个新的 `<h1>`），然后将该元素添加到网页中。这与您使用 DOM 或 jQuery 库的过程类似。在React中，有一系列的函数来实现这个功能：\n\n```react\n//Import required functions from the React libraries\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\n\n//Create a new `<h1>` element using React methods. This function takes\n//arguments indicating what the element should be\nconst msgElem = React.createElement(\n  //html tag\n  'h1',\n  //object of attributes\n  { id: 'hello', className: 'myClass' },\n  //content\n  'Hello World!'\n);\n\n//Create a \"React root\" out of the `#root` elemment\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n//render the React element at that root\nroot.render(element)\n```\n\n- `React.createElement()` 允许你创建元素，`ReactDOM.createRoot()`给渲染React元素创造了环境(context)，经常的，在`div#root` 里创建。`root.render(element)` 将把创建的root里的内容替换为element的内容。\n\n  > 注意 `class` 属性在创建时被标记为 **`className`** 。这是为了防止和JavaScript的 `class` 关键字冲突。\n\n> The `createRoot()` function was introduced with React v18 (March 2022). Previous versions of React used the `ReactDOM.render()` function directly instead of explicitly creating a root context. Using `ReactDOM.render()` will cause your app to function as if using React v17, preventing some advanced features from working.\n\n你或许发现了， `React.createElement()` 括号内的内容非常复杂，因此，React允许你使用JSX，一种JavaScript的语法扩展来在JavaScript里直接写HTML标签：\n\n```jsx\n//Create a new `<h1>` element using JSX syntax\nconst element = <h1 id=\"hello\" className=\"myClass\">Hello World</h1>;\n\n//Create a \"React root\" out of the `#root` elemment\n//then render the React element at that root\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(element)\n```\n\n> 注意 `class` 属性在创建时被标记为 **`className`** 。这是为了防止和JavaScript的 `class` 关键字冲突。\n\n分配给元素变量的值不是字符串（没有引号）。相反，它是调用 `React.createElement()` 函数的简写 -- 类似 HTML 的语法被自动转换为实际的 JavaScript 方法调用，从而让书写更简单。\n\n**注意：** 依然要在最后加上 `;` ！！！\n\nJSX也可以定义多个元素，只需加上一对括号即可：\n\n```jsx\n//JSX can define nested elements\nconst header = (\n  <header className=\"banner\">\n    <h1>Hello world!</h1>\n  </header>\n);\n```\n\n**注意：**类似于XML，JSX也要求所有元素都被“关闭”。因此，你必须在空元素最后加上一个 `/`：\n\n```jsx\n//JSX elements must be closed\nconst picture = <img src=\"my_picture.png\" alt=\"a picture\" />\n```\n\n实际上，JSX并非真正的HTML，只是在Webpack构建的时候，其会自动调用一个叫做 [**Babel**](https://babeljs.io/) 的工具来 transpling 相关的代码。同样的，CRA也已经帮我们配置好了。\n\n- Yes, chaining tools together like this is [how modern web development works](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f).\n\n### 行内表达式\n\nJSX也允许你在HTML里使用JavaScript表达式：\n\n```jsx\nconst message = \"Hello world!\";\nconst element = <h1>{message}</h1>;\n```\n\n任何表达式都可以！\n\n```jsx\n//Including an inline expression in JSX. The expressions can be mixed directly\n//into the HTML\nconst element = <p>A leap year has {(365 + 1) * 24 * 60} minutes!</p>;\n```\n\n你还可以定义一个 `Object`定义一堆属性，然后使用*spread operator* (`...`)把它们赋给HTML：\n\n```jsx\n//Define a JavaScript variable\nconst imgUrl = 'path/to/my_picture.png';\n\n//Assign that variable to an element attribute\nconst pic = <img src={imgUrl} alt=\"A picture\" />;\n\n//Define an object of element attributes\nconst attributes = {\n    src: 'path/to/other_picture.png',\n    alt: 'Another picture'\n};\n\n//A DOM element that includes those attributes, among others.\n//The spread operator applies the property names as attributes of the element.\nconst otherPic = <img {...attributes} className=\"my-class\" />;\n```\n\n同样的，这些表达式也可以进行嵌套，实现HTML元素的嵌套：\n\n```jsx\n//Define variable content to display. One is a string, one is a React element.\nconst greetingString = \"Good morning!\";\nconst iconElem = <img src=\"sun.png\" alt=\"A wide awake sun\" />;\n\n//Conditionally change values based on an `isEvening` value (defined elsewhere)\nif(isEvening) {\n    greetingString = \"Good evening!\";\n    iconElem = <img src=\"moon.png\" alt=\"A dozing moon\" />;\n}\n\n//Include the variables inline in another React element\n//Notice how the `icon` element is included as a child of the `<header>`\nconst header = (\n    <header>\n      <h1>{greetingString}</h1>\n      {iconElem}\n    </header>\n);\n```\n\n数组里的一组行内元素会被当成父元素底下的一组兄弟元素：\n\n```jsx\n//An array of React elements. Could also produce via a loop or function\nconst listItems = [<li>lions</li>, <li>tigers</li>, <li>bears</li>];\n\n//Include the array as an inline expression; each `<li>` element will be\n//included as a child of the `<ul>`\nconst list = (\n  <ul>\n    {listItems}\n  </ul>\n);\n```\n\n最后，如果你要在JSX里写注释，只能使用 `/* */` 这种写法，使用HTML的` <!-- -->` 和JavaScript的行注释 `//` 都是无效的！\n\n```jsx\nconst main = (\n    <main>\n      { /* A comment: the main part of the page goes here... */ }\n    </main>\n)\n```\n\n\n\n## React组件\n\n使用React构建页面的时候，通常使用组件来搭建页面。\n\n组件就像是页面中的一小块，它们可以通过相互组合和嵌套来组成复杂的页面。\n\n### 定义组件\n\n组件通常被定义为函数，但是一般以帕斯卡命名法来命名（PascalCase）：\n\n```jsx\n//Define a Component representing information about a user\nfunction UserInfoCard(props) {\n  //This is an everyday function; you can include any code you want here\n  //including variables, if statements, loops, etc\n  const name = \"Ethel\";\n  const descriptor = \"Aardvark\";\n\n  //Return a React element (JSX) that is how the Component will appear\n  return (\n    <div>\n      <h1>{name}</h1>\n      <p>Hello, my name is {name} and I am a {descriptor}</p>\n    </div>\n  )\n}\n\n//Create a new value (a React element)\n//This syntax in effect \"calls\" the function\nconst infoElement = <UserInfoCard />;\n\n//Show the element in the web page (inside #root)\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(infoElement);\n```\n\n因此，当你看到某个JavaScript函数的名字是驼峰命名法命名的时候，你就知道这是一个React组件。\n\n- 组件函数的返回值通常是一个JSX，请尽可能将返回的JSX写得简洁明了，如果有需要进行复杂的代码表达式运算、逻辑运算、循环等等，请在返回值外的函数体内进行。\n\n- 也有一些库会将组件写成匿名函数并赋值给一个 `const` 变量，不过处于易读性的考虑不推荐这样做：\n\n```jsx\nconst Example = (props) => {\n  return <div>...</div>\n}\n```\n\n- 组件通常会接入一个参数，这个参数按惯例被命名为 `props`，详见下面的[介绍](#Props)\n\n- 组件函数的返回值一般用一个 `<div>` 包裹，当然，在有些情况下，如果你不希望用div，你可以使用[Fragment](https://reactjs.org/docs/fragments.html)来包裹返回值：\n\n  ```jsx\n  function FragmentExample(props) {\n    return (\n      <>\n        <p>First paragraph</p>\n        <p>Second paragraph</p>\n      </>\n    )\n  }\n  ```\n\n- 当组件被定义后，就可以使用XML标签的格式来使用它 (i.e., as `<UserInfoCard />`)，**不要直接调用组件函数！！！**（比如 `UserInfoCard()` ）\n\n  \n\n- 组件也可以相互嵌套使用，非常灵活：\n\n  ```jsx\n  //A component representing a message\n  function HelloMessage(props) {\n    return <p>Hello World!</p>;\n  }\n  \n  //A component representing another message\n  function GoodbyeMessage(props) {\n    return <h1>See ya later!</h1>;\n  }\n  \n  //A component that is composed of (renders) other components!\n  function MessageList(props) {\n    return (\n      <div>\n        <h1>Messages for you</h1>\n        <HelloMessage /> {/* include a HelloMessage component */}\n        <GoodbyeMessage /> {/* include a GoodbyeMessage component */}\n      </div>\n    );\n  }\n  \n  //Render an instance of the \"top-level\" (\"outer\") component\n  const root = ReactDOM.createRoot(document.getElementById('root'));\n  root.render(<MessageList />);\n  ```\n\n实际上，React 应用程序是由许多不同的组件（Components）组成的，根据应用程序的大小，组件的数量可达几十个甚至上百个！最顶部的组件通常称为 `App`，App 的返回值会实例化更多子组件，每个子组件代表页面的不同部分。\n\n`App` 组件将代表网站的全部内容，其他组件将作为 `<App>` 的子组件。但是，由于 React 组件将被插入到 `index.html` 文件中的 `<div id=\"root\">` 元素内，你不需要在 React 组件中包含 `<body>` 或 `<head>` 元素 ---- 这些元素已经在 HTML 文件中定义好了，因此不会由 React 创建！\n\n### Strict Mode\n\n在CRA提供的初始代码里，你会发现 `<App>` 组件被嵌在 `<React.StrictMode>` 组件中：\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n [**`StrictMode`**](https://reactjs.org/docs/strict-mode.html) 组件由React对象提供，就像JavaScript的 `use strict`  声明一样，这个组件会激活很多React内置的错误检查，尽管这些错误检查有些有点过时，且会使一些 `console.log` 输出多次，但还是很有用。\n\n\n\n## 组件的层次结构\n\n组织组件的层次结构的原则是：使你能快速地找到你的代码，并使你的App的结构简洁易懂！\n\n你可以把不同的模组分开，也可以放在同一个文件中。一种可能的结构如下：\n\n```bash\nsrc/\n|-- components/\n  |-- App.js\n  |-- navigation/\n    |-- NavBar.js\n  |-- utils/\n    |-- Alerts.js\n    |-- Buttons.js\nindex.js\n```\n\n记住，组件是用函数来表示的，因此你需要使用 `import` 和 `export` 来引入和导出它们。组件之间不要相互包含！而是应该有一定的层次结构，一直向上到 `index.js` ：\n\n```jsx\n/* in Messages.js file */\n\n//Export the defined components (as named exports)\nexport function HelloMessage() { /* ... */ }\n\nexport function GoodByeMessage() { /* ... */ }\n```\n\n```jsx\n/* in App.js file */\n\n//Import components needed from other modules\nimport { HelloMessage, GoodbyeMessage } from `./Messages.js`; //named imports!\n\n//Can also export as a _default_ export; common if the file has only one component\nexport default function App() {\n    return (\n        <div>\n            {/* Use the imported components */}\n            <HelloMessage />\n            <GoodbyeMessage />\n        </div>\n    )\n}\n```\n\n```jsx\n/* in index.js file */\n\n//Import components needed from other modules\nimport App from `./App.js`; //default import!\n\n//Render the imported component\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n注意，`index.js` 通常只会引入一个组件。\n\n## class组件\n\n**当前定义组件最好的方法就是使用函数组件！** 但是，为了适应使用老版本的React写的代码，最好了解一下class组件。\n\n在更老的版本中，React组件也可以用 `class` 关键字来声明。这个类*继承*了 [**`React.Component`**](https://reactjs.org/docs/react-component.html) 类 -- 这表示你定义的其实是一个React Component!：\n\n```jsx\n//Define a class component representing information about a user\nclass UserInfo extends React.Component {\n    //Components MUST override the `render()` function, which must return a\n    //DOM element\n    render() {\n        //This is an everyday function; you can include any code you want here\n        const name = \"Ethel\";\n        const descriptor = \"Aardvark\";\n\n        //Return a React element (JSX) that is how the component will appear\n        return (\n            <div>\n                <h1>{name}</h1>\n                <p>Hello, my name is {name} and I am a {descriptor}</p>\n            </div>\n        )\n    }\n}\n\n//instantiate the class as a new value (a React element)\nconst infoElement = <UserInfo />;\n\n//Show the element in the web page (inside #root)\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(infoElement);\n```\n\n这和之前使用函数来定义组件非常类似，你只需把函数体换成类里的方法 `render()` 即可。\n\n- 注意： `React.Component` 类经常在引入时被赋了别名，所以你可以直接使用它的别名:\n\n  ```jsx\n  import {Component} from 'react';\n  \n  class MyComponent extends Component {\n      render() {\n          //...\n      }\n  }\n  ```\n\n> Additionally, older versions of React included a function `React.createClass()` that took in an *object* whose properties were functions that would act as class methods (see [here](https://toddmotto.com/react-create-class-versus-component/) for details). Although this function has been removed, it’s worth being aware of in case you come across older examples of React code that you need to interpret or adapt.\n\n## props\n\n使用React组件的好处是往往我们能够向组件中传递一组现成的数据，然后在页面中渲染出我们想要的效果。当这些数据发生改变时，组件也会将页面重新渲染。\n\n函数组件会接入一个 `Object` 类型的参数，按惯例命名为 `props` （properties）。\n\n在创建组件的时候，可以用 `propName=\"value\"` 的形式向组件传递props。因为是JavaScript的标识符，所以用驼峰命名法（camelCase）：\n\n```jsx\n//Passing a prop called `message` with value \"Hello property\"\nconst messageA = <MessageItem message=\"Hello property!\" />;\n\n//Passing a prop using an inline expression\nconst secret = \"Shave and a haircut\";\nconst messageB = <MessageItem message={secret} />;\n\n//A component can accept multiple props\n//This component takes in a `userName` prop as well as a `descriptor` prop\nconst userInfo = <UserInfo userName=\"Ethel\" descriptor=\"Aardvark\" />;\n```\n\n虽然你可以多传或少传props，但一般组件会定义它们所需要的props，最好和其保持一致。\n\n并且，组件在拿到props之后，一般会使用 Object Destructing 把props对象里的键值转换成变量：\n\n```jsx\nfunction UserInfo(props) {\n    //assign the prop object properties to variables\n    const {userName, descriptor} = props;\n\n    return <h1>{userName}</h1>;\n}\n```\n\n另一种的destructuring的方法：\n\n```jsx\n//The props object passed in will be destructured into two argument variables\nfunction UserInfo({userName, descriptor}) {\n    return <h1>{userName}</h1>;\n}\n```\n\n但为了保持简洁，之后的例子将不做destructuring，而是将props直接使用。\n\nprops可以为任意类型，数组、函数，甚至另一个组件也没问题！\n\n```jsx\n//Props can be of any data type!\n\n//Pass an array as a prop!\nconst array = [1,2,3,4,5];\nconst suitcase = <Suitcase luggageCombo={array} />;\n\n//Pass a function as a prop (like a callback)!\nfunction sayHello() {\n    console.log('Hello world!');\n}\nconst greeting = <Greeting callback={sayHello} />;\n\n//Pass another Component as a prop (not common)!\nconst card = <HolidayCard message=\"Greetings world!\" />\nconst gift = <Gift toMsg=\"Ethel\", fromMsg={card} />\n```\n\n实际上，将回调函数作为props传递给其他组件是构建interactive React 应用的一种常见做法。\n\n### props的传递\n\nReact的组件经常嵌套着使用，这意味着在一个组件中返回的JSX里包含有其他子组件。这些子组件的props需要通过父组件来向下传递给它们，即数据是自顶向下一层层**单向**传递的。\n\n```jsx\n//Defines a component representing a message in a list\nfunction MessageItem(props) {\n    return <li>{props.message}</li>\n}\n\n//A component that renders a trio of messages\nfunction MessageListTrio(props) {\n    const messages = props.messages; //assign prop to a local variable for convenience\n\n    return (\n        <div>\n            <h1>Messages for you</h1>\n            <ul>\n                {/* instantiate child components, passing data from own props */}\n                <MessageItem message={messages[0]} />\n                <MessageItem message={messages[1]} />\n                <MessageItem message={messages[2]} />\n            </ul>\n        </div>\n    );\n}\n\n//Define and pass a prop to the parent comment when rendering it\nconst messagesArray = [\"Hello world\", \"No borders\", \"Go huskies!\"];\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<MessageListTrio messages={messagesArray} />);\n```\n\n在React中，创建List的常用方法就像上述代码所示那样：先给单个的列表对象创建一个子组件(e.g., `MessageItem`)，然后再给所有的单个列表项创建一个总组件(e.g., `MessageList`)来包含它们。\n\n在传输含有大量数据的数据集，比如数组的时候，我们就可以使用 `map()` 函数来将父组件拿到的数据集分别拆分给一个个子组件：\n\n```jsx\n//Map an array of message strings to an array of components\nconst msgItems = props.messages.map((msgString) => {\n    const component = <MessageItem message={msgString} />; //pass prop down!\n    return component; //add this new component to resulting array\n})\n```\n\n由于JSX会将一个作为行内元素的含有组件的数组渲染为相同的兄弟元素，所以创建列表变得非常方便，不需要写额外的循环：\n\n```jsx\nfunction MessageList(props) {\n  //the data: an array of strings [\"\", \"\"]\n  const messageStringArray = props.messages;\n\n  //the renderable content: an array of elements [<>, <>]\n  const msgElemArray = messageStringArray.map((msgString) => {\n    const component = <MessageItem message={msgString} />; //pass prop down!\n    return component; //add this new component to resulting array\n  })\n\n  return (\n    <div>\n      <h1>Messages for you</h1>\n      <ul>\n        {/* render the array of MessageList components */}\n        {msgElemArray}\n      </ul>\n    </div>\n  );\n}\n\n//Define and pass a prop to the parent comment when rendering it\nconst messagesArray = [\"Hello world\", \"No borders\", \"Go huskies!\"];\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<MessageList messages={messagesArray});\n```\n\n但是，上面这种写法会触发console的警告，原来，我们还要给每个子组件分别分配一个 `key` props，否则系统将无法追踪每个组件。（类似HTML的 `id` 属性，其实如果不指定，系统也会默认将组件在数组中的index作为 `key` 分配，但这样在数组元素发生变化的时候任意造成混乱，所以建议还是手动指定 `key` 为妙）。\n\n现在，我们用对象数组来包含 `key` ：\n\n```jsx\nconst MESSAGE_DATA = [\n    {content: \"Hello world\", id: 1}\n    {content: \"No borders\", id: 2}\n    {content: \"Go huskies!\", id: 3}\n];\n\nfunction MessageList(props) {\n  //the data: an array of objects [{}, {}]\n  const messageObjArray = props.messages;\n\n  //the renderable content: an array of elements [<>, <>]\n  const msgElemArray = messageObjArray.map((msgObject) => {\n    //return a new MessageItem for each message object\n    //attributes are listed on their own lines for readability\n    return <MessageItem\n              message={msgObject.content}\n              key={msgObject.id.toString()} {/* pass in a key prop! */}\n              />;\n  }) //end of .map()\n\n  return (\n    <div>\n      <h1>Messages for you</h1>\n      <ul>\n        {msgElemArray}\n      </ul>\n    </div>\n  ); //end of return\n}\n\n//Define and pass a prop to the parent comment when rendering it\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<MessageList messages={MESSAGE_DATA});\n```\n\n\n\n\n\n\n\n## 其他资料\n\n组件思维：如何使用React来构建界面 https://react.dev/learn/thinking-in-react\n\nReact小项目：Tutorial: [Tic-Tac-Toe](https://react.dev/learn/tutorial-tic-tac-toe)\n\n"},{"title":"ES6 feature Note","url":"/ES6-feature-Note/","content":"\n# ES6+ 特性\n\n2015年，ES6标准发布，增加了许多新特性。这里将对这些特性进行讨论，特别是那些被用于React框架里的特性。\n\n> 注意，[大部分浏览器](http://kangax.github.io/compat-table/es6/)现在都支持ES6特性，但IE依然不支持，如果你需要兼容IE，你可以使用 [Babel](https://babeljs.io/) compiler来将代码“重新编译”为ES5代码。你可以在React框架里用 build tools自动完成重新编译。\n\n## 类\n\nES6引入了新的 `class` 关键字，使你可以像Java那样面向对象编程。\n\n- 注意，在JavaScript里，所有的类的实例都是 `Object` 类型的变量，尽管它表现得很像Java中的类，但还是有所不同。\n\n### Why Class？\n\n引入类的好处是：我们可以对一些数据（变量）和行为（方法）提供封装，以便在更高层面的抽象上来讨论它们。\n\n在JavaScript中，我们可以通过定义 `Object` 类型的变量来定义一个实例：\n\n```javascript\nlet person = {\n   name: 'Ada',\n   age: 21,\n   costume: 'Cheshire Cat'\n   trickOrTreat: function(newCandy){\n      this.candy.push(newCandy);\n   }\n}\n\n//tell me about this person!\nconsole.log(person.name + \" is a \" + person.costume);\n```\n\n但类给我们提供了一个批量创建实例的模版，我们通过实例化类来创建同一类的不同对象。\n\n### Java中的类\n\n复习一下，在Java中定义类：\n\n```java\n//class declaration\npublic class Person {\n\n    //attributes (private)\n    private String firstName;\n    private int age;\n\n    //a Constructor method\n    //this is called when the class is instantiated (with `new`)\n    //and has the job of initializing the attributes\n    public Person(String newName, int newAge){\n        //assign parameters to the attributes\n        this.firstName = newName;\n        this.age = newAge;\n    }\n\n    //return this Person's name\n    public String getName() {\n        return this.firstName; //return own attribute\n    }\n\n    //grow a year\n    public void haveBirthday() {\n        this.age++; //increase this person's age (accessing own attribute)\n    }\n\n    //a method that takes in a Person type as a parameter\n    public void sayHello(Person otherPerson) {\n        //call method on parameter object for printing\n        System.out.println(\"Hello, \" + otherPerson.getName());\n\n        //access own attribute for printing\n        System.out.println(\"I am \" + this.age +  \" years old\");\n    }\n}\n```\n\n在Java中使用类：\n\n```java\npublic static void main(String[] args) {\n    //instantiate two new People objects\n    Person aliceObj = new Person(\"Alice\", 21);\n    Person bobObj = new Person(\"Bob\", 42);\n\n    //call method on Alice (changing her fields)\n    aliceObj.haveBirthday();\n\n    //call the method ON Alice, and PASS Bob as a param to it\n    aliceObj.sayHello(bobObj);\n}\n```\n\n这里对语法进行一个总结：\n\n1. 使用 `class` 关键字对类进行声明；\n2. Java的类中的变量（attributes）在类的定义顶部定义；\n3. Java**使用构建函数**来初始化类的实例化对象里的变量；\n4. 类的方法定义在类定义的内部，使用该类的实例调用类里定义的方法时可以使用：`obj.foo()`\n5. 在类里调用类的方法和变量时可以用 `this.attr` 和 `this.foo()` 来调用；\n6. 使用 `new` 关键字来实例化对象，实例化对象是一个变量，可以作为参数传递；\n\n### ES6的类\n\n定义如下：\n\n```javascript\n//class declaration\nclass Person {\n\n    //a Constructor method\n    //this is called when the class is instantiated (with `new`)\n    //and has the job of initializing the attributes\n    constructor(newName, newAge) {\n        //assign parameters to the attributes\n        this.firstName = newName;\n        this.age = newAge;\n    }\n\n    //return this Person's name\n    getName() {\n        return this.firstName; //return own attribute\n    }\n\n    //grow a year\n    haveBirthday() {\n        this.age++; //increase this person's age (accessing own attribute)\n    }\n\n    //a method that takes in a Person type as a parameter\n    sayHello(otherPerson) {\n        //call method on parameter object for printing\n        console.log(\"Hello, \" + otherPerson.getName());\n\n        //access own attribute for printing\n        console.log(\"I am \" + this.age +  \" years old\");\n    }\n}\n```\n\n用例如下：\n\n```javascript\n//instantiate two new People objects\nlet aliceObj = new Person(\"Alice\", 21);\nlet bobObj = new Person(\"Bob\", 42);\n\n//call method on Alice (changing her attributes)\naliceObj.haveBirthday();\n\n//call the method ON Alice, and PASS Bob as a param to it\naliceObj.sayHello(bobObj);\n```\n\n几点note：\n\n1. JavaScript也使用 `class` 关键字来定义类；\n\n   - 所有类变量名都需要使用PascalCase命名法！\n\n2. JavaScript中定义类不需要事先声明变量，所有的变量在未被定义时都是 `undefined`;\n\n3. JavaScript中的构造函数只有一个，名字就叫：`constructor()`；\n\n4. 在JavaScript的类里定义方法的时候不需要使用 `function` 关键字；\n\n5. 实例化对象的方式和Java是一样的，使用 `new` 关键字，比如：\n\n   `let aliceObj = new Person(\"alice\", 21);`\n\n6. 和Java不同，你可以在一个文件里定义多个类：\n\n```javascript\n//script.js\n'use strict';\n\n//declare a class\nclass Dog {\n    bark() { /*...*/ }\n}\n\n//declare another class\nclass Cat {\n    meow() { /*...*/ }\n}\n\n//declare a (non-class) function\nfunction petAnimal(animal) { /*...*/ }\n\n//at the \"main\" level, instantiate the classes and call the functions\nlet fido = new Dog();\npetAnimal(fido); //pass this Dog object to the function\n```\n\n### 继承\n\nES6也允许类的继承，就像Java一样，使用 `extend` 关键字来继承：\n\n```js\n//The \"parent/super\" class\nclass Dog {\n  constructor(name) {\n      this.name = name;\n  }\n\n  sit() {\n      console.log('The dog '+this.name+' sits. Good boy.');\n  }\n\n  bark() {\n      console.log('\"Woof!\"');\n  }\n}\n\n//The \"child/sub\" class (inherits abilities from Dog)\nclass Husky extends Dog {\n    constructor(name, distance) {\n        super(name); //call parent constructor\n        this.distance = distance;\n    }\n\n    //a new method (\"special ability\")\n    throwFootball() {\n        console.log('Husky '+this.name+' throws '+this.dist+' yards');\n    }\n\n    //override (replace) parent's method\n    bark() {\n      super.bark(); //call parent method\n      console.log(\"(Go huskies!)\");\n    }\n}\n\n//usage\nlet dog = new Husky(\"Harry\", 60); //make a Husky\ndog.sit(); //call inherited method\ndog.throwFootball(); //call own method\ndog.bark(); //call own (overridden) method\n```\n\n继承允许一个子类继承父类的方法和在父类的基础上实现更多的专有功能，且允许你覆写（override）父类的方法。\n\n> 但注意，JavaScript不是一门面向对象语言，而是使用了 [prototype system](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes) 来定义 `Object` 对象， 这个特性允许 [prototypical inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance) ，ES6的 `class` 只是提供了一种简洁的语法来实现指定对象的 prototypes罢了。这种特性从第一版的JavaScript里就存在了。\n>\n> See [this (detailed) explanation](http://aaditmshah.github.io/why-prototypal-inheritance-matters/) for further discussion.\n\n\n\n## 箭头函数\n\nES6提供了一种快速简洁的匿名函数写法：lamda functions / arrow functions:\n\n```js\nlet sayHello = (name) => {\n    return 'Hello '+name;\n}\n\n// equal to:\nlet sayHello = function(name) {\n  return 'Hello '+name;\n}\n```\n\n几点tips：\n\n- 如果箭头函数没有参数，那么必须在 `=>` 前面加上 `()`，如果箭头函数有两个及以上的参数，也必须加上 `()` 但是，如果仅有一个参数，你可以直接写成：`let sayHello = name => 'Hello '+name;` ；尽管如此，还是建议加上括号以方便阅读；\n- 如果箭头函数只有一个语句，那么你可以省略 `{}` ；\n- 如果箭头函数只有一个语句，且该语句return了一个值，那么你可以省略 `return` ；\n\n- 但如果函数不返回值，还是建议使用 `{}` 将函数体包围起来；\n\n```js\nlet array = [1,2,3]; //an array to work with\n\n//normal function\narray.map(function(num) {\n  return num*2; //multiply each item by 2\n});\n\n//arrow syntax\narray.map(num => {\n  return num*2; //multiply each item by 2\n});\n\n//concise body\narray.map(num => num*2);\n```\n\n箭头函数非常简洁，正在快速变成标准的JS匿名函数写法。\n\n**尽可能使用箭头函数来表示匿名函数！！！**原因见[这里](#why-use-arrow-functions)。\n\n## this关键字\n\n如前所述，this可以用来指代当前的对象：\n\n```js\nlet doggy = {\n  name: \"Fido\",\n  bark: function() {\n      console.log(this.name, \"woofs\"); //`this` is object the function was called on\n  }\n}\n\ndoggy.bark(); //=> \"Fido woofs\"\n```\n\n但请注意，function是变量，所以可以被重新赋值；而this是在**执行时间（execution time）**里实时定义的，因此其代表了在运行代码时指向的对象：\n\n```js\n//An object representing a Dog\nlet doggy = {\n  name: \"Fido\",\n  bark: function() { console.log(this.name + \" woofs\"); }\n}\n\n// An object representing another Dog\nlet doggo = {\n  name: \"Spot\",\n  bark: function() { console.log(this.name + \" yips\")}\n}\n\n//This is Fido barking\ndoggy.bark( /*this = doggy*/ ); //=> \"Fido woofs\"\n\n//This is Spot barking\ndoggo.bark( /*this = doggo*/ ); //=> \"Spot yips\"\n\n//This is Fido using Spot's bark!\ndoggy.bark = doggo.bark; //assign the function value to `doggy`\ndoggy.bark( /*this = doggy*/) //=> \"Fido yips\"\n```\n\n- 注意 this 关键字指向的是调用方法的对象！\n\n### 回调函数的问题\n\n看下面这段代码：\n\n```js\nclass Person {\n   constructor(name){ this.name = name; } //basic constructor\n\n   //greet each person in the given array\n   greetAll(peopleArray) {\n      //loop through each Person using a callback\n      peopleArray.forEach(function(person) {\n         console.log(\"Hi\"+person.name+\", I'm \"+this.name);\n      });\n   }\n}\n```\n\n由于 `forEach()` 的回调函数是在需要时才被调用，其被调用时并不是通过 **dot notation**来调用的，所以调用时里面的 `this.name` 就变成了 `undefined.name`，因此触发报错： `TypeError: Cannot read property 'name' of undefined`.\n\n解决这个问题的方法就是**用箭头函数**来写匿名回调函数！\n\n箭头函数有一个特性：和周围的代码共享语义上的 `this` 关键字。<span id=\"why-use-arrow-functions\">这就是你为什么总是需要使用箭头函数来表示匿名回调函数的原因！</span>\n\n```js\nclass Person {\n   constructor(name){ this.name = name; }\n\n   greetAll(peopleArray) {\n      peopleArray.forEach((person) => { //arrow function (subtle difference)\n         console.log(\"Hi\"+person.name+\", I'm \"+this.name); //works correctly!\n      });\n   }\n}\n```\n\n> 除此之外，你也可以用 `function.bind()` 来永久地把一个 `this` 和某个函数绑定，这样无论谁调用这个函数，它所代表的this永远不变：\n>\n> ```js\n> //re-assign function\n> myFunction = myFunction.bind(thisValue);\n> ```\n>\n> `.bind()` 会返回一个新函数，上面是常用的用法：把新返回的绑定好this的函数赋值给旧函数。\n>\n> This is a common pattern in React (and has some minuscule performance benefits), 但是在这门课程中：you should stick with arrow functions for cleanliness and readability.\n\n## Destructuring and Spreading\n\n[**destructing assignments**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)：你可以destruct一个数组或对象，即将它们的值一次性赋给一组分立的变量：\n\n```js\nlet myArray = [1, 2, 3];\nlet [x, y, z] = myArray; //assign myArray elements to `x`, `y`, `z` respectively\nconsole.log(x); //=> 1;\nconsole.log(y); //=> 2;\nconsole.log(z); //=> 3;\n```\n\n```js\nlet myObject = {a: 1, b: 2, c: 3};\nlet {a, b, c} = myObject;\nconsole.log(a); //=> 1\nconsole.log(b); //=> 2;\nconsole.log(c); //=> 3;\n```\n\n注意，当destruct一个对象的时候，如果等式左边的变量名和对象的 key 名字不同，那么就不会被赋给相应的值，而是为 `undefined` 。\n\n如果你想要把值赋给不同名字的变量，见： There is syntax to assign values to different variable names as well, see [the documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring) for details.\n\n### Spreading\n\n如果等式左边的变量和数组或对象里的内容数量不同时，我们可以使用 `...` ( [**spread operator**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) ) 来将溢出的值塞到一个数组里：\n\n```js\nlet dimensions = [10, 20, 30, 40];\nlet [width, height, ...rest] = dimensions\nconsole.log(width);  //=> 10\nconsole.log(height); //=> 20\nconsole.log(rest);   //=> [30, 40]; the rest of the values!\n```\n\n同样的，如果一个函数需要传入不定数目的变量时，也可以使用 `...` ：\n\n```js\n//a function that logs out all of the parameters\nfunction printArgs(...args){\n    //all the parameters will be grouped into a single array `args`\n    args.forEach((arg) => {\n        console.log(arg) //can log out all of them, no matter how many!\n    });\n}\n\nprintArgs('a', 'b', 'c'); //=> \"a\" \"b\" \"c\"\nprintArgs(1,2,3,4,5,6); //=> \"1\" \"2\" \"3\" \"4\" \"5\" \"6\"\n\n//a function that adds up all the arguments (no matter how many!)\nfunction sum(...numbers) {\n    //numbers is an array, so we can `reduce()` it!\n    let total = numbers.reduce((runningTotal, num) => {\n        return runningTotal + num; //new total\n    }, 0); //start at 0\n\n    return total;\n\n    //or as one line with a concise arrow function:\n    return numbers.reduce((total, n) => total+n);\n}\n\nsum(3 ,4, 3); // => 10\nsum(10, 20, 30, 40); // => 100\n```\n\n\n\n## 模块化\n\n当代码变得复杂冗长的时候，再把所有的代码都放在一个 `.js` 文件里就不太合适了。\n\n> Such large files become difficult to read and debug (“where *was* that function defied?”), can introduce problems with the shared global namespace (“did I already declare a `user` variable?”), and overall mixes code in a way that violates the *Separation of Concerns* principle.\n\n把代码拆分为不同的 “Module” 使其各司其职是一个好办法。你不需要使用 `<script>` 标签来逐个引入它们，ES6提供了一系列功能来组织它们。\n\n最经常的做法是使用外部工具，如[webpack](https://webpack.js.org/)之类的来加载modules。在这些情况下，您将使用 Node JavaScript 运行时提供的模块加载器。\n\n**虽然不经常这么用**，但如果你需要在浏览器里面使用Modules，你需要在 `<script>` 标签里声明 `type=\"module\"` attribute。\n\n```html\n<!-- load a script that can include other modules -->\n<script type=\"module\" src=\"path/to/script.js\"></script>\n```\n\n### modules 语法\n\n> 本节介绍网络应用程序中使用的 ES6 模块（ECMAScript 规范的一部分）。不过，Node.js 默认使用另一种模块加载系统 [*CommonJS*](https://nodejs.org/docs/latest/api/modules.html#modules_modules)。该系统使用内置方法 `require()` 加载模块（结果返回一个 \"导出 \"变量）。通过将值赋值给 `module.exports` 全局变量来导出模块。本课程将专门使用 ES6 模块，但最好还是了解一下另一种 *CommonJS* 方法。\n\n#### Import\n\n和Java非常类似，使用 `import` 关键字来引入：\n\n```java\n//Java example: import `Random` variable from `java.util` to use globally\nimport java.util.Random\n```\n\n```js\n//JavaScript: import the `Random` variable from a `util.js` module\nimport { Random } from './util';\n```\n\n在 `{}` 里包含你要引入的变量名（记住，函数也是变量！），然后在 `from` 关键字后面写上modules所在的相对路径；\n\n- 注意：Node-based System，比如React，允许你省略 `.js` 扩展名。\n- 注意：如果你没有使用 `./` 之类的来指定路径，Node Module加载器会自动取 Load Path （e.g., in `node_modules/`）寻找对应的modules。有时加载外部JS库我们会这么做：\n\n```js\n//with jquery installed in `node_modules/`\n//import the `$` and `jQuery` variables\nimport {$, jQuery} from 'jquery';\n```\n\n#### Export\n\n想要让另一个文件访问某个module里的变量，你需要先Export它们：\n\n```js\n/*** my-module.js ***/\nexport let question = \"Why'd the chicken cross the road?\";\nexport let answer = \"To get to the other side\";\nexport function laugh() {\n    console.log(\"hahaha\");\n}\n```\n\n上面的方法叫做 **“name export”**，后面还会介绍**“default export”**。只要某个变量被import了，那么它就是全局可用的。 (just as if it were defined in a previous `<script>` tag)\n\n有好几种方法来import和export：\n\n```js\n/*** my-module.js ***/\nexport function foo() { return 'foo'; } //make available (as above)\n\nfunction bar() { return 'bar'; }\nexport bar; //export previously defined variable\n\nexport { bar as barFunction }; //provide an \"alias\" (consumer name) for value\n\n//will not be available (a \"private\" function)\nfunction baz() { return 'baz'; }\n```\n\n```js\n/*** index.js ***/\nimport {foo, barFunction} from './my-module'; //import multiple values\nfoo() //=> 'foo'\nbarFunction() //=> 'bar'\n\nimport {foo as myFoo} from './my-module'; //provide an \"alias\" for value\nmyFoo(); //=> 'foo'\n\nimport * as theModule from './my-module'; //import everything that was exported\n                                          //loads as a single object with values\n                                          //as properties\ntheModule.foo(); //=> 'foo'\ntheModule.barFunction(); //=> 'bar'\ntheModule.baz(); //Error [private function]\n```\n\n通过 `as` 关键字，你可以指定某个变量的“假名”，so it is loaded and assigned a different name。这使得你可以将模块里复杂的名字重命名为更简单的名字。\n\n你也可以import everything：使用 `import * as` 语法，你可以指定一个代表导出Module的对象名称（如示例中的`theModule`），每个导出变量都将是该对象的属性。**当你在开发过程中可能要向模块添加额外的导出值，但又不想不断调整导入语句时，这种方法特别有用。**\n\n\n\n以及，“default export” 允许每个模块只导出一个默认的变量，为引入模块提供了一些简化。\n\n```js\n/*** my-module.js ***/\n//this function is the \"default\" export\nexport default function sayHello() {\n    return 'Hello world!';\n}\n```\n\n在 `export` 后使用 `default` 关键字，这样就可以在引入时只需提供假名来直接引入默认变量。\n\n```js\n/*** index.js ***/\nimport greet from './my-module'; //import the default value\n\ngreet(); //=> \"Hello world!\"\n```\n\n匿名变量也可以作为default输出：\n\n```js\n/*** animals.js ***/\nexport default ['lion', 'tiger', 'bear']; //export anonymous array\n```\n\n默认导出技术在 React 等面向对象框架中尤为常见，在这些框架中，您可以让每个 JavaScript 模块都包含一个函数或类的代码。可以将单个类作为默认导出，这样其他模块就可以快速轻松地导入它，如\n\n```js\nimport MyComponent from './MyComponent.js'\n```\n\n## 其他特性\n\n> Syntactic Sugar causes cancer of the semicolon - [Alan Perlis](http://www.cs.yale.edu/homes/perlis-alan/quotes.html)\n\n### Template Strings\n\nES6允许你在字符串里直接插入表达式：使用后勾号（\\```）而不是引号来标注，并将注入的表达式写在 `${}` 标记内：\n\n```js\nlet name = 'world';\nlet greeting = `Hello, ${name}!`; //template string\nconsole.log(greeting); //=> \"Hello, world!\"\n```\n\n然而在字符串里放太多的表达式会影响程序的可读性，所以：\n\n```js\nlet name = 'world';\n\n//greeting with capitalization. Don't do this!\nlet greeting = `Hello, ${name.substr(0,1).toUpperCase() + name.substr(1)}!`\nconsole.log(greeting); //=> \"Hello, world!\";\n\n//do this instead!\nlet capitalizedName = name.substr(0,1).toUpperCase() + name.substr(1);\nlet greeting = `Hello, ${capitalizedName}`\nconsole.log(greeting); //=> \"Hello, world!\";\n```\n\n比较常见且可能有用的 ES6 特性，其中大部分只是 \"语法糖\"，使用 ES5 风格的 JavaScript 也能实现类似的行为和功能。因此，您不需要在代码中使用这些功能（尽管它们可能会有所帮助），它们通常会在我们使用 React 等库的过程中出现。\n\n"},{"title":"DOM note","url":"/DOM-note/","content":"# DOM\n\n参考：[Document Object Module(DOM)](https://info340.github.io/dom.html)\n\nDOM是Document of module的缩写。当浏览器渲染 `html` 时，我们往往把其看成树状的结构，没有父节点的html元素被成为根元素，有父元素也有子元素的被称为node，没有子元素的被成为leaf。这种模型就叫做DOM。\n\nJavaScript则可以用来操纵和修改DOM里的元素，DOM提供了一些API使我们可以很方便的对页面中的 html 元素进行操纵。\n\n## 全局变量\n\nJavaScript的全局变量几乎都是 `Object` 类型，它们的值是一组方法。比如：`Math` ， `console` ，`window` 等等：\n\n比如，全局变量 `window` 代表浏览器自身：\n\n```js\n/* example properties */\nlet width = window.innerWidth;   //viewport width\nlet height = window.innerHeight; //viewport height\nvar url = window.location.href; //url for this page\n\n/* example functions */\nwindow.alert(\"Boo!\"); //show a popup alert. Do not use this.\nwindow.scrollTo(0, 1000); //scroll to a position\nwindow.setTimeout(callback, 1000); //execute callback after an delay\nwindow.setInterval(callback, 1000); //execute callback repeatedly after interval\n```\n\n\n\n> While these examples are included for completeness, most `window` functions are rarely used and should be avoided. Popups with the `window.alert()` function are inelegant, interrupt the user’s actions, and produce a bad user experience—you should instead use in-window alerting options instead (such as showing a `<p class=\"alert\">`). Browser control functions such as `scrollTo()` are non-standard and can vary drastically across systems and platforms. Proceed with caution when using `window` functions!\n\n\n\n### document\n\n`document` 是DOM本身的全局变量，即当前浏览器页面中渲染的全部 html ，通过 `document` 对象来操纵当前页面的元素。\n\n## 引用html元素\n\n为了操纵html文件，你需要先引用它们。\n\n`document` 对象里有许多“选择函数” 使你可以轻松引用到你想要的元素：\n\n```js\n//element with id=\"foo\"\nlet fooElem = document.getElementById('foo');\n\n//elements with class=\"row\"\nlet rowElems = document.getElementsByClassName('row'); //note the plural!\n\n//<li> elements\nlet liElems = document.getElementsByTagName('li'); //note the plural!\n\n/*easiest to select by reusing CSS selectors! */\nlet cssSelector = 'header p, .title > p';  //a string of a CSS selector\n\n//selects FIRST element that matches css selector\nlet elem = document.querySelector(cssSelector);\n\n//matches ALL elements that match css selector\nlet elems = document.querySelectorAll(cssSelector);\n```\n\n- `querySelector` 是最常用的选择函数，你可以在括号里填 `id` ，`class` 或 `元素选择器` 来选出需要的元素。\n- 注意：所有返回多个元素的选择函数返回的是一个  [`NodeList`](https://developer.mozilla.org/en-US/docs/Web/API/NodeList)，尽管它很像数组，但是 `forEach()` 和 `map()` 等方法对其无效！你必须使用 `for()` 循环来遍历它的元素！\n- 一般而言，你一次只会对一个元素进行修改，所以不需要太担心上一点。\n\n\n\n## 修改HTML元素\n\n一旦你获得了html元素的引用，你就可以使用对象里对应的方法来对其进行修改。注意，修改后的元素不会影响到html源文件，刷新页面后，你的修改就会被覆盖（除非你同时也加载了对应的 `script` 文件）\n\n### 修改元素的内容\n\n使用 `elem.textContent` 来修改字面内容，这是一种非常安全的做法，即使有人试图引入 `<` 和 `>` ，它们也会被翻译为[HTML Entities](https://www.w3schools.com/html/html_entities.asp)而不是标签。\n\n使用`elem.innerHTML` 则可以插入带有HTML标签的文字，注意，除非你能100%确定输入的内容是可靠的，否则请小心使用这个属性。\n\n```js\n//get a reference to the FIRST <p> element\nlet elem = document.querySelector('p');\n\nconsole.log(elem); //to demonstrate\n\nlet text = elem.textContent; //the text content of the elem\nelem.textContent = \"This is different content!\"; //change the content\n\nlet html = elem.innerHTML; //content including HTML\nelem.innerHTML = \"This is <em>different</em> content!\"; //interpreted as HTML\n```\n\n\n\n### 修改元素的属性\n\n你也可以改变某个元素的属性，在HTML Specification里定义的每个属性（attribute）都作为元素的property暴露出来。\n\n```js\n//get a reference to the `#picture` element\nlet imgElem = document.querySelector('#picture');\n\n//access the attribute\nconsole.log( imgElem.src ); //logs the source of the image\n\n//modify the attribute\nimgElem.src = 'my-picture.png';\n```\n\n但是，你不可以使用`elem.class` 和 `elem.style`来访问某个属性的类名和CSS。\n\n使用 `getAttribute()` 方法和 `setAttribute()` 方法可以直接对某个属性进行修改，注意给出对应的参数：\n\n```js\nlet imgElem = document.querySelector('#picture');\nimgElement.setAttribute('src', 'my-other-picture.png'); //set the src\n\nconsole.log( imgElem.getAttribute('src') ); //=> 'my-other-picture.png'\n\n//the `hasAttribute()` method returns a boolean.\nlet isThick = document.querySelector('svg rect')\n                      .hasAttribute('stroke-width'); //chained anonymous variables\n```\n\n你可以用上述方法来修改未被HTML Spec定义的属性，比如说`data-` attribute。但它们对一些属性也不起作用，比如： `value` attribute of an `<input>` element。\n\n### 修改元素的类名和CSS\n\n使用 `classList` 属性来修改类名。除了IE以外，可以使用 `add()` 和 `remove()` 方法来增加和减少类名：\n\n```js\n//access list of classes of the element 'elem'\nlet classList = elem.classList;\n\n//add a class\nelem.classList.add('small'); //add a single class\nelem.classList.add('alert','alert-warning'); //add multiples classes (not on IE)\n\n//remove a class\nelem.classList.remove('small');\n\n//\"toggle\" (add if missing, remove if present)\nelem.classList.toggle('small');\n```\n\n- While IE 10+ does support these methods, it doesn’t support *multiple arguments* for them (so you can’t add multiple classes in a single method call). If you need to support older browsers (including any version of IE), you can instead modify the `.className` property as if it were a String:\n\n  ```js\n  //fallback for IE (all)\n  var classes = elem.className;\n  classes += ' '+ 'sweet sour'; //modify the string (append!)\n  elem.className = classes;     //reassign\n  ```\n\n  The `classList` methods work perfectly on Microsoft Edge.\n\n你也可以直接修改 `style` 属性，但一般不推荐这么改：\n\n```js\nlet h1 = document.querySelector('h1');\nh1.style.color = 'green';\nh1.style.backgroundColor = 'black'; //not `.background-color`\n```\n\n### 修改DOM Tree\n\n你也可以操纵DOM Tree，即增加或删减、修改页面里的元素。\n\nJavaScript的DOM元素可以使用特殊的变量来引用它们的子元素和父元素，这些变量具有只读属性。\n\n```html\n<main>\n    <section id=\"first-section\">\n        <p>First paragraph</p>\n        <p>Second paragraph</p>\n    </section>\n    <section id=\"second-section\"></section>\n<main>\n```\n\n```js\n//get reference to the first section\nlet firstSection = document.querySelector('#first-section');\n\n//get reference to the \"parent\" node\nlet main = firstSection.parentElement;\nconsole.log(main); //<main>...</main>\n\n//get reference to the child elements (2 paragraphs)\nlet paragraphs = firstSection.children;\nconsole.log(paragraphs.length); //2\nconsole.log(paragraphs[0]); //<p>First paragraph</p>\n\n//get reference to the the next sibling\nlet sectionSection = firstSection.nextElementSibling;\nconsole.log(secondSection); //<section id=\"second-section\"></section>\n```\n\n- Note that these properties only deal with **HTML elements**—text content nodes are ignored. You can instead use equivalent properties `parentNode` and `childNodes` to also consider text content nodes.\n\n即除了元素节点之外，DOM里面还可以有：“A node can be an element node, a text node, a comment  node, or a document node.”\n\n以及：SVG content doesn’t support `parentElement`, but does support `parentNode`.\n\n\n\n你可以使用 `Document.createElement()` 来创建新的元素，然后使用 `appendChild()` 等方法来将新创建的元素插入DOM：\n\n```js\n//create a new <p> (not yet in the tree)\nlet newP = document.createElement('p');\nnewP.textContent = \"I'm new!\";\n\n//create Node of textContent only (not an HTML element, just text)\nlet newText = document.createTextNode(\"I'm blank\");\n\nlet main = document.querySelector('main');\nmain.appendChild(newP); //add element INSIDE (at end)\nmain.appendChild(newText); //add the text inside, AFTER the <p>\n\n//add anonymous new node BEFORE element. Parameters are: (new, old)\nmain.insertBefore(document.createTextNode(\"First!\"), newP);\n\n//replace node. Parameters are: (new, old)\nmain.replaceChild(document.createTextNode('boo'), newText);\n\n//remove node\nmain.removeChild(main.querySelector('p'));\n```\n\n常见的做法是使用 `document.createElement()` 先创建一个块元素，然后设置这个块元素的 `innerHTML`，在里面添加文字内容和行内元素，最后使用 `appendChild()` 把这个元素放到DOM的某个位置中去。\n\n### Accessibility\n\n如果在阅读器已经阅读后对DOM的内容进行了修改，那么 Accessibility 就会受到影响。将将来可能被修改的元素放到[ARIA Live Region](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)，阅读器会根据修改进行调整。\n\nYou make an element into a live region by giving it the `aria-live` attribute:\n\n```html\n<div aria-live=\"polite\">\n  This content can change!\n</div>\n```\n\n`aria-live` 的属性 `\"polite\"` 表明只有当用户暂停当前正在阅读的内容的时候才把修改的内容读出。\n\n> A `\"polite\"` alert doesn’t interrupt the currently being read text or description, but instead will be injected when there is a break (if the current reading goes on for too long, then the new content will not be spoken).\n\n> The other option is `\"assertive\"`, which indicates that the new content should be spoken as soon as it changes, possibly interrupting other content. This should only be used for important information (like alerts, warnings, or errors), as it can interrupt the user’s flow in ways that are very disorienting. In short: *always be polite!*\n\n另外你也可以使用 `\"assertive\"` 属性，这表示一旦发生改变，改变的内容会被立刻读出。\n\n## 事件\n\n当用户和电脑互动的时候，操作系统会把这一系列互动当做 “事件（Event）”，比如按键被按下，鼠标点击等等。\n\n为了使我们的JavaScript能够对事件进行响应，我们需要注册“Event Listener” 来监听事件。在DOM API中，我们使用函数 `addEventListener()` 来给某个元素添加事件监听。\n\n该函数有两个参数：\n\n- 预先定义的事件名称\n- 事件发生时调用的回调函数，该函数有一个类型是 Object 的参数 `event` ，里边包含了事件发生的一些信息\n\n```js\n//a (named) callback function\nfunction onClickCallback() {\n    console.log(\"You clicked me!\");\n}\n\n//get a reference to the element we want to \"listen\" to\nlet button = document.querySelector('button');\n\n//register a listener for 'click' events\nbutton.addEventListener('click', onClickCallback);\n```\n\n一般我们使用匿名函数：\n\n```js\nlet button = document.querySelect.select('button');\nbutton.addEventListener('click', function(event) {\n    console.log(\"You clicked me!\");\n});\n```\n\n可以给同一个元素绑定多个不同的事件监听器。\n\n回调函数的参数 `event` 含有事件发生时的信息，比如事件发生时鼠标的位置，哪个元素触发了事件等等：\n\n```js\nelem.addEventListener('click', function(event) {\n   //get who was clicked;\n   let clickedElem = event.target; //target property of the event\n   console.log(clickedElem);\n});\n```\n\n如果你想要覆盖掉某事件发生时系统默认的行为，比如取消在按下按钮时默认提交表格：\n\n```js\nsubmitBtn.addEventListener('click', function(event) {\n\n  event.preventDefault(); //don't do normal behavior\n  event.stopPropagation(); //don't pass the event to parents\n\n  //..do custom behavior here\n\n  return false; //don't do normal behavior OR propagate! (for IE)\n})\n```\n\n### 事件的类型\n\nThere are [numerous different events](https://developer.mozilla.org/en-US/docs/Web/Events) that you can listen for, including:\n\n- [Mouse Events](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) 比如 **`'click'`**。 \n\n  -  `event.offsetX` 和 `event.offsetY` will provide (x,y) coordinates for the clicks location *relative to the target element*; \n  -  `clientX/Y` for coordinates relative to the browser window\n  -  `pageX/Y` for coordinates relative to the document (regardless of scrolling). \n  - See [this post](http://www.quirksmode.org/mobile/viewports.html) for details, and [this page](http://www.quirksmode.org/m/tests/mouseprops.html) for an example.\n\n  其他的鼠标事件还包括： `'dblclick'` (double-click), `'mousedown'` (mouse button is pressed down, may be held), `'hover'` (mouse hover), `'mouseenter'` (mouse moves over element), `'mousemove'` (mouse moves over element), and `'mouseleave'` (mouse moves off element).\n\n\n\n\n\n- [Keyboard Events](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) 比如 **`'keydown'`**。\n  - `event.key` 属性用来判断按下的是哪个键, giving a [predefined key value](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) you can check:\n\n```js\nelem.addEventListener('keydown', function(event){\n    if(event.key === 'ArrowUp'){\n        console.log(\"Going up!\")\n    }\n    //...\n});\n```\n\n> The `event` object also has properties to check if any “modifier keys” such as shift, control, or meta (Windows/command) are held when the event occurs.\n>\n> Note that you almost always want to respond to the `'keydown'` and `'keyup'` events; the `'keypressed'` event is sent later and only applies to non-modifier keys.\n\n\n\n\n\n- [Window Events](https://developer.mozilla.org/en-US/docs/Web/API/Window#Event_handlers) 是 `window` 全局变量的事件。 \n  - 比如， `'resize'` 事件可以用来确定浏览器窗口是否发生了大小改变 (e.g., if you want to make the content responsive as well as the CSS):\n\n```js\nwindow.addEventListener(\"resize\", function() {\n    //...\n});\n```\n\n(See [the documentation](https://developer.mozilla.org/en-US/docs/Web/Events/resize) for advise on using this callback)\n\n- `window` 全局变量还定义了一个事件回调函数 `window.onload` ，允许你在页面加载完毕后再运行此回调函数内的代码(e.g., for scripts specified in the `<head>`)\n\n  ```js\n  window.onload = function() {\n      //...do stuff once page is ready (e.g., run the rest of your code)\n  }\n  ```\n\n\n\n**注意：** 永远不要在HTML里使用 `onclick` 属性！为了与解耦的原则保持一致，永远应该在JavaScript里添加Event Listener！\n\n\n\n### 事件驱动编程\n\n在事件监听器中定义的回调函数里的变量的作用域只在函数内有效，这就意味着有时我们需要使用全局变量来记录事件的一些属性，比如事件发生的次数：\n\n```js\nlet clickCount = 0;  //keep track of the \"state\" (global)\ndocument.querySelector('button').addEventListener('click', function() {\n    if(clickCount > 10) {  //decide what to do\n        console.log(\"I think you've had enough\");\n    }\n    else {\n        clickCount++;  //change state (+1)\n        console.log('You clicked me!');\n    }\n});\n```\n\n> These “state” variables can be global, or can simply be declared within a containing function as a closure. State variables are often objects, with individual values stored as the properties. This provides a name-spacing feature, and helps to keep the code from being cluttered with many variables.\n\n"},{"title":"JavaScript Note","url":"/JavaScript-Note/","content":"# JavaScript\n\nJavaScript和Java没啥关系。它是ECMAscript标准的实现，所以JavaScript的版本又叫做`ES`，本篇描述了ES5的语法。\n\n## 发展历程\n\nES5是2009年提出的，ES6在2015年提出，已经被大量浏览器支持。最后是2016年完成的ES7，但还未被可靠的支持。\n\n每个版本都会添加一些额外的简化语法，特定的关键字以及核心函数。每个版本也都前向兼容。只要浏览器内置的解释器支持，就可以使用JavaScript的新特性。\n\n\n\n## JavaScript的运行\n\n在浏览器中，当页面的HTML被逐行渲染时，遇到`<script>` 标签时，就会下载并执行JavaScript语句。\n\n```html\n<!-- execute the script.js file -->\n<script src=\"path/to/my/script.js\"></script>\n```\n\n**注意：**`<scrip>` 标签不是 empty的，这意味着它需要 `</script>` 来结尾。你也可以在标签内直接写JavaScript语句，但是除了调试的时候，其他时间不建议这么做。\n\n### \\<script>标签的位置\n\n`<script>` 标签既：\n\n- 放在 `<head>` 标签的里面时，在页面内容加载前执行JavaScript语句。\n- 放在`<body>` 标签内的最后一行时，在页面内容加载完毕后执行JavaScript的语句。\n\n主流做法是在 `<body>` 之后写 `<script>` 语句，但你也可以使用 `defer` 属性来设置在内容加载完毕之后再下载和运行JavaScript语句，但IE9及以前的IE不支持这个特性。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <!-- include here to run before the page appears -->\n  <script src=\"js/script.js\"></script>\n</head>\n<body>\n   ... content ...\n\n   <!-- include here to run \"after\" html appears -->\n   <!-- we will usually do this -->\n   <script src=\"js/script.js\"></script>\n</body>\n<html>\n```\n\n你还可以在浏览器里面打开终端来使用JavaScript并查看输出和打印信息，**You should always have the JavaScript Console open when developing JavaScript code, since this is where any error messages will appear!**\n\n### 使用node.js\n\n使用JavaScript的解释器node.js在本地命令行里运行JavaScript。\n\n在安装了node的机器的命令行里输入 `node` 语句来打开 *interactive Node session*，然后在出现的 `>` 后输入要执行的语句。要退出会话，输入 `quit()` 后回车或按 `ctrl` + `z` 即可。\n\n如果要运行一个 `.js` 文件，输入：\n\n```shell\nnode my-script.js\n```\n\n## JavaScript的基本语法\n\n在一个`.js`文件中是没有 `main()` 函数的概念的。\n\n程序逐行执行，每行可声明一个变量或函数，然后在后续的行使用它们。**每行的结尾最好加上 `;` ，虽然解释器有时可以容忍你漏掉分号，但是为了避免意外错误的发生，还是加上为好。**\n\n要打印某些信息，使用：`console.log()`\n\n### strict mode\n\n在文件顶部声明：\n\n```javascript\n'use strict';\n```\n\n可以告诉解释器使用严格模式。（注意这是一个解释器声明而不是字符串！）\n\n在严格模式下，解释器会更加严谨地处理语法。\n\n比如，如果你尝试使用一个未被声明的变量的时候，严格模式下解释器将报错，而非严格模式下，编译器就使用 `undefined` 作为值。严格模式可以捕捉到一些silly mistakes。\n\n> **ALWAYS USE STRICT MODE!** It will help avoid typo-based bugs, as well as enable your code to run more efficiently.\n\n### 变量\n\n#### let和var\n\n我们使用 `let` 关键字来定义变量。\n\n注意，我们不会声明变量的类型(e.g., `int` or `String`)，变量类型在JavaScript里是动态的，即变量的类型就是赋值给它的值的类型(e.g., `Number`, `String`, etc.)。\n\n```javascript\nlet message = 'Hello World';  //a String\nconsole.log(typeof message);  //=> `string`\n\nlet shoeSize = 7;  //a Number\nconsole.log(typeof shoeSize);  //=> 'number'\n```\n\n- 使用 `typeof` 运算符来查看变量的类型。\n\n```shell\n> let a = 10;\n> typeof a;\n'string'\n```\n\n\n\n- 在JavaScript里使用camelCase来命名变量。\n\n> **Pro Tip:** Even though variables in JavaScript loosely typed, the data type of a value is still important! In order to help keep track of the type of each variable in JavaScript, include the type in the variable name. For example: `textString`, `wordsArray`, `totalNum`, `itemStr`, etc..\n\n\n\n- 声明的变量默认值为 `'undefined'` ，类似Java里的 `null`。尽管JavaScript里也有 `null` 类型，但不常用。\n\n```js\n//create a variable (not assigned)\nlet hoursSlept;\nconsole.log(hoursSlept);  //=> undefined\n```\n\n\n\n- 注意，`let` 关键字是ES6标准引入的，之前使用的是 `var` 关键字。它们之间的区别：\n  - `let` 的作用域是 `{}` 之间的区域\n  - `var` 的作用域是该变量定义的函数内，即如果你在此函数内的 `if` 语句模块内用 `var` 定义的变量仍在此函数的 `if` 语句模块外有效\n  - 使用 `let` 最好，因为作用域更清晰，但如果你要兼容老设备：e.g., IE 10, Safari 9.3, Android 4.4，那还是用 `var` 吧，或者transpile你的代码。\n\n#### const\n\n常数变量也可以使用 `const` 来声明（只读变量？），且只能被赋值一次。\n\nconst变量的作用域和let一样，都是**block scoped**。\n\n```js\nconst ISCHOOL_URL = 'https://ischool.uw.edu'; //declare constant\nISCHOOL_URL = 'https://example.com'; //TypeError: Assignment to constant variable.\n```\n\n### 基本数据类型\n\n### Number\n\n可以进行数值运算的类型，常用的数学函数可以使用 预置的 `Math` 类来调用。\n\n```js\nlet x = 5;\ntypeof x;  //'number'\nlet y = x/4;\ntypeof y;  //'number'\n\n//numbers use floating point division\nconsole.log( x/4 );  //1.25\n\n//use the Math.floor() function to do integer division\nconsole.log( Math.floor(x/4) );  //1\n\n//other common Math functions available as well\nconsole.log( Math.sqrt(x) );  //2.23606797749979\n```\n\n\n\n### String\n\n使用 `'` 或 `\"` 括起来的就是String类型的变量，推荐使用单引号。\n\n可以使用加好对字符串进行连接。\n\n```js\nlet name = 'Joel';\nlet greeting = 'Hello, my name is '+name; //concatenation\n```\n\nString也有一堆方法。和Java一样，这里String类型也是immutable的。所以String方法会返回一个新字符串：\n\n```javascript\nlet message = 'Hello World';\nlet shouted = message.toUpperCase();\nconsole.log(shouted);  //=> 'HELLO WORLD'\n```\n\n\n\n### Boolean\n\n只要两种值：`true` 和 `false` \n\n通常使用比较逻辑时返回的值为布尔值，布尔值也支持逻辑运算。\n\n\n\n### Array\n\nJavaScript Arrays are written as literals inside square brackets **`[]`**. Individual elements can be accessed by (0-based) *index* using **bracket notation**.\n\n```js\n//an array of names\nlet names = ['John', 'Paul', 'George', 'Ringo'];\n\n//an array of numbers (can contain \"duplicate\" values)\nlet numbers = [1, 2, 2, 3, 5, 8];\n\n//arrays can contain different types (including other arrays!)\nlet things = ['raindrops', 2.5, true, [3, 4, 3]];\n\n//arrays can be empty (contain no elements)\nlet empty = [];\n\n//access using bracket notation\nconsole.log( names[1] );  // \"Paul\"\nconsole.log( things[3][2] );  // 3\n\nnumbers[0] = '340';  //assign new value at index 0\nconsole.log( numbers );  // [340, 2, 2, 3, 5, 8]\n```\n\nJavaScript的数组是可以 outbound 的，你可以给任意的下标元素赋值，数组会自动增长到这个下标的长度，并且给中间未赋值的元素赋值为 `undefined` 。\n\n获取数组的长度，可以使用 `.length` 属性，**注意，返回值永远是最后一个元素 + 1**。\n\n```js\nlet letters = ['a', 'b', 'c'];\nconsole.log(letters.length);  // 3\nletters[5] = 'f';  //grows the array\nconsole.log(letters);  // [ 'a', 'b', 'c', , , 'f' ]\n                       //blank spaces are undefined\nconsole.log(letters.length);  // 6\n```\n\n数组也有许多方法，你可以使用这些方法来操弄数组，就像Java的 `ArrayList` 一样：\n\n```js\n//Make a new array\nlet array = ['i','n','f','o'];\n\n//add item to end of the array\narray.push('340');\nconsole.log(array); //=> ['i','n','f','o','340']\n\n//combine elements into a string\nlet str = array.join('-');\nconsole.log(str); //=> \"i-n-f-o-340\"\n\n//get index of an element (first occurrence)\nlet oIndex = array.indexOf('o'); //=> 3\n\n//remove 1 element starting at oIndex\narray.splice(oIndex, 1);\nconsole.log(array); //=> ['i','n','f','340']\n```\n\n\n\n### Object\n\n包含键值对的一种数据结构。使用“String”类型作为“key”来获取其中储存的\"value\"。\n\nvalue的数据类型可以是任意的，比如“Number”，“Array”，甚至是另一个Object。\n\nJavaScript的Object数据类型更像是Java里的HashMap（实际上JavaScript的Object就是用Hash table数据结构来实现的），Python里的dictionary，而**和面向对象编程里的对象没啥关系**（当然，它也可以用来实现面向对象编程）。\n\n```js\n//an object of ages (explicit Strings for keys)\n//The `ages` object has a `sarah` property (with a value of 42)\nlet ages = {'sarah':42, 'amit':35, 'zhang':13};\n\n//different properties can have the same values\n//property names with non-letter characters must be in quotes\nlet meals = {breakfast:'coffee', lunch: 'coffee', 'afternoon tea': 'coffee'}\n\n//values can be of different types (including arrays or other objects!)\nlet typeExamples = {number:12, string:'dog', array:[1,2,3]};\n\n//objects can be empty (contains no properties)\nlet empty = {}\n```\n\n- 注意，Object里的数据是无序的，你使用 `console.log()` 打印它的属性值时，打印的结果是乱序的！\n\n- 用 `console.log` 打印Object的时候，所有属性都会完整地被打印出来。但是，如果你尝试把对象转换为“String”类型，比如 `let output = 'my obj' + expObj`，那么最终打印出的结果是：\n\n  ```shell\n  my obj[obj Object]\n  ```\n\n  打印的是\"string\"版本的Object，显然不是我们想要的结果。注意下面两种打印Object的方法的区别！\n\n  ```js\n  let myObject = {a:1, b:2}\n  \n  //convert object to string, won't log nicely\n  console.log(\"My object: \" + myObject); //=> My object: [object Object]\n  \n  //log the object directly\n  console.log(\"My object \", myObject); //=> My object {a: 1, b: 2}\n  ```\n\n#### 面向对象式编程\n\n可以像Java的对象一样使用JavaScript的Object数据类型，每个property就像是一个attribute（或称之为“*实例对象*”）一样。\n\n```js\n//an object representing a Person (spacing is for readability; white-space is ignored)\nlet person = {\n  firstName: 'Alice',\n  lastName: 'Smith',\n  age: 40,\n  pets: ['rover', 'fluffy', 'mittens'],  //value is an array\n  favorites: {   //value is another object\n    music: 'jazz',\n    food: 'pizza',\n    numbers: [12, 42]  //value is an array\n  }\n}\n```\n\n#### Accessing Object\n\n两种方法：\n\n- `obj['key']`\n- `obj.key`\n\n如果访问了不存在的对象，那么得到的值是 `undefined` 。\n\n两种方法的区别：\n\n使用方括号 `[]` 访问时可以在里面放表达式或变量的值，如：`obj[variable]`，但其他情况下建议使用 `obj.key` 这种用法。\n\n```js\nlet favorites = {music: 'jazz', food: 'pizza', numbers: [12, 42]};\n\n//access variable\nconsole.log( favorites['music'] ); //'jazz'\n\n//assign variable\nfavorites['food'] = 'cake';  //property name is a string\nconsole.log( favorites['food'] ); //'cake'\n\n//access undefined key\nconsole.log( favorites['language'] ); //undefined\nfavorites['language'] = 'javascript'; //assign new key and value\n\n//access nested values\nconsole.log( favorites['numbers'][0] ); //12\n\n//use a variable as the \"key\"\nlet userInputtedTopic = 'food'; //pretend this value is supplied dynamically\nconsole.log(favorites[userInputtedTopic]);  //'cake'\n```\n\n```js\nlet favorites = {music: 'jazz', food: 'pizza', numbers: [12, 42]};\n\n//access variable\nconsole.log( favorites.music ); //'jazz'\n\n//assign variable\nfavorites.food = 'cake';\nconsole.log( favorites.food ); //'cake'\n\n//access undefined key\nconsole.log( favorites.language ); //undefined\nfavorites.language = 'javascript'; //assign new key and value\n\n//access nested values\nconsole.log( favorites.numbers[0] ); //12\n```\n\n\n\n**获取含有所有key的数组**：<span id=\"obj-key-method\">使用 `Object.key()` 方法</span>：\n\n```js\nlet ages = {sarah:42, amit:35, zhang:13};\nlet keys = Object.keys(ages);  // [ 'sarah', 'amit', 'zhang' ]\n```\n\n**注意：** JavaScript没有获取全部value的方法，你只能遍历所有的key来逐个获取它们的values。\n\n\n\n#### Object Array\n\nObject和Array可以嵌套使用：\n\n> As noted above, both arrays and objects can have values of any type—including other arrays or objects! The ability to nest objects inside of objects is incredibly powerful, and allows us to define arbitrarily complex information structurings (schemas). \n\n```js\n//an arbitrary list of people's names, heights, and weights\nlet people = [\n    {name: 'Ada', height: 58, 'weight': 115},\n    {name: 'Bob', height: 59, 'weight': 117},\n    {name: 'Chris', height: 60, 'weight': 120},\n    {name: 'Diya', height: 61, 'weight': 123},\n    {name: 'Emma', height: 62, 'weight': 126}\n]\n```\n\n> Each object (record) acts as a “row” in the table, and each property (feature) acts as a “column”. As long as all of the objects share the same keys, this array of objects *is* a **table**!\n\n\n\n### 类型转换\n\n不像其他编程语言，JavaScript不会在你对不同类型的变量使用运算符的时候报错，而是进行一些自动类型转换，但请小心，有时候这可能会造成意想不到的后果：\n\n```js\nlet x = '40' + 2;\nconsole.log(x);  //=> '402'; the 2 is coerced to a String\nlet y = '40' - 4;\nconsole.log(y);  //=> 36; can't subtract strings so '40' is coerced to a Number!\n```\n\n#### \\== 和 \\===\n\n在使用 `==` 的时候，JavaScript会自动进行类型转换，所以尽管类型不同，但是只要值是一样的，返回的结果就是 `true` ：\n\n```js\nlet num = 10\nlet str = '10'\n\nconsole.log(num == str) //true, the values can be coerced into one another\n```\n\n如果要对类型是否一致也进行检查，**请使用 `===` 和 `!==` **：\n\n```js\nlet num = 10\nlet str = '10'\n\nconsole.log(num === str) //false, the values have different types\n```\n\n\n\n虽然经常自动转换的类型为“String”，但有时候JavaScript也会转换为“Boolean”，特别是在比较两个变量的时候：\n\n```js\n//compare an empty String to the number 0\nconsole.log( '' == 0 ); //true; both can be coerced to a `false` value\n```\n\n因为空字符串 ` ' '` 和数字 `0` 都被认为是“假值”（可以被强制转换为 false 的值），所以 `==` 比较的结果返回 `true` 。其他的假值包括 undefined、null 和 NaN（非数字）。而其他所有的值都会被强制转换为 true。\n\n> For more examples of the horror of JavaScript coercion, see [this video](https://www.destroyallsoftware.com/talks/wat) (about 1:20 in).\n\n\n\n### 控制结构\n\n#### if-else\n\n```js\nif(condition){\n  //statements\n}\nelse if(alternativeCondition) {\n  //statements\n}\nelse {\n  //statements\n}\n```\n\n 用于 `undefined` 的变量会自动转换为 `false`，所以用下面这种写法来判断变量是否被初始化很常见：\n\n```js\n//check if a `person` variable has a `name` property\nif(person.name){\n    console.log('Person does have a name!');\n}\n```\n\n- 你也可以使用三元运算符来表示分支结构：\n\n```js\nlet x; //declare variable\nif(condition) {\n    x = 'foo';\n} else {\n    x = 'bar';\n}\n\n//can be condensed into:\nlet x = condition ? 'foo' : 'bar';\n```\n\n\n\n#### 循环\n\n> JavaScript also supports **`while`** loop (for indefinite iteration) and **`for`** loops (for definite iteration) similar to Java. The only difference is that because JavaScript variables are dynamically typed, the *loop control variables* are not declared with a type:\n\n```js\n//an example for loop. The `i` is not declared as an int\nfor(let i=0; i<array.length; i++){\n  console.log(array[i]);\n}\n```\n\n**注意：**JavaScript有 `for...in...` 这个结构，但是 “ it doesn’t work as you would expect for arrays and it iterates over “enumerable properties” rather than the specific indices”。而ES6引入的 `for...of...` 可以用来遍历数组，但浏览器都不支持这个特性。因此**目前的最佳做法是使用上述 for 循环**，或者下一章介绍的 **`forEach()` 方法**。\n\n- 如果你要遍历一个Object的所有key，使用 `Object.key()` 方法来获取遍历循环所需的键数组！用法见[这里](#obj-key-method)\n\nchatGPT：\n\n在 JavaScript 中，`for...in` 和 `for...of` 是两种不同的循环语句，它们有以下区别和用法：\n\n1. `for...in` 循环：\n\n   - 用于遍历对象的可枚举属性。\n   - 循环变量表示每个属性的键（key）。\n   - 迭代顺序不确定，可能不按照对象属性的顺序进行遍历。\n   - 通常不用于遍历数组，因为遍历数组时会返回索引而不是数组元素。\n\n   示例用法：\n\n   ```js\n   const obj = { a: 1, b: 2, c: 3 };\n   for (let key in obj) {\n     console.log(key); // 输出：a, b, c\n     console.log(obj[key]); // 输出：1, 2, 3\n   }\n   ```\n\n2. `for...of...` 循环：\n\n   - 用于遍历可迭代对象（例如数组、字符串、Set、Map 等）的值。\n   - 循环变量表示每个元素的值。\n   - 迭代顺序按照对象的迭代协议（iterator protocol）规定的顺序进行遍历。\n   - 不可用于遍历普通对象，因为普通对象并不是可迭代的。\n\n   示例用法：\n\n   ```js\n   const arr = [1, 2, 3];\n   for (let value of arr) {\n     console.log(value); // 输出：1, 2, 3\n   }\n   \n   const str = \"Hello\";\n   for (let char of str) {\n     console.log(char); // 输出：H, e, l, l, o\n   }\n   ```\n\n总结：\n\n- `for...in` 用于遍历对象的属性，返回属性的键（key）。\n- `for...of` 用于遍历可迭代对象的值，返回元素的值。\n- `for...in` 不适用于遍历数组，而 `for...of` 可以遍历数组。\n\n### 函数\n\nJavaScript的函数定义和Java很相似，就是没有`public static` 和返回值，以及不需要为变量指定类型：\n\n```js\n//A function named `makeFullName` that takes two arguments\n//and returns the \"full name\" made from them\nfunction makeFullName(firstName, lastName) {\n  //Function body: perform tasks in here\n  let fullName = firsName + \" \" + lastName;\n\n  // Return: what you want the function to output\n  return fullName;\n}\n\n// Call the makeFullName function with the values \"Alice\" and \"Kim\"\n// Assign the result to `myName`\nlet myName = makeFullName(\"Alice\", \"Kim\")  // \"Alice Kim\"\n```\n\n- As in other languages, function arguments in JavaScript are **implicitly declared *local* variables**.\n- 如果没有return语句，函数默认返回 `undefined`\n- JavaScript的函数所有的变量都是可选的，即调用函数时你可以少传参数（未被赋值的默认为 `undefined` ）或者多传参：\n\n```js\nfunction sayHello(name) {\n    return \"Hello, \"+name;\n}\n\n//expected: argument is assigned a value\nsayHello(\"Joel\");  //\"Hello, Joel\"\n\n//argument not assigned a value (left undefined)\nsayHello();  //\"Hello, undefined\"\n\n//extra arguments (values) are not assigned to variables, so are ignored\nsayHello(\"Joel\", \"y'all\");  //\"Hello, Joel\"\n```\n\n\n\n\n\n## JS函数式编程\n\n### 函数即变量\n\n在JavaScript中，函数就是变量：\n\n```js\n//create a function called `sayHello`\nfunction sayHello(name) {\n    console.log(\"Hello, \"+name);\n}\n\n//what kind of thing is `sayHello` ?\nconsole.log(typeof sayHello);  //=> 'function'\n```\n\n所以，你也可以把函数赋值给其它变量：\n\n```js\n//create a function called `sayHello`\nfunction sayHello(name) {\n    console.log(\"Hello, \"+name);\n}\n\n//assign the `sayHello` value to a new variable `greet`\nlet greet = sayHello;\n\n//call the function assigned to the `greet` variable\ngreet(\"world\");  //logs \"Hello world\"\n```\n\n### 匿名函数\n\n你可以用两种方式来定义实名函数：\n\n- 直接声明实名函数\n- 把匿名函数的值赋给一个变量\n\n```js\n//named function (normal)\nfunction sayHello(person){\n    console.log(\"Hello, \"+person);\n}\n\n//an anonymous function (with no name!)\n//(We can't reference this without a name, so writing an anonymous function is\n//not a valid statement)\nfunction(person) {\n    console.log(\"Hello, \"+person);\n}\n\n//anonymous function (value) assigned to variable\n//equivalent to the version in the previous example\nlet sayHello = function(person) {\n    console.log(\"Hello, \"+person);\n}\n```\n\n#### 提升\n\n上述两种方法唯一的区别就在于“提升”：\n\nJavaScript解释器在读取文件的时候，会在执行任何语句前，前把所有的变量和函数声明放到内存里。这看起来就像把这些声明“提升”到了文件的顶部。\n\n**提升只适用于实名函数！**使用将匿名函数赋值给变量的做法不会使函数的定义被提升。**请在使用任何函数之前先声明和定义函数！**\n\n\n\n### Object 函数\n\n函数是变量，Object的属性是变量，因此可以把函数设置为Object的属性：\n\n```js\n//an object representing a dog\nlet dog = {\n    name: 'Sparky'\n    breed: 'mutt'\n}\n\n//assign an anonymous function to the `bark` property\ndog.bark = function(){\n    console.log('woof!');\n}\n\n//call the function\ndog.bark(); //logs \"woof!\"\n```\n\n这就像给对象创建了一个方法成员一样！the `dog` object now has a function `bark()` !\n\n#### this\n\n就像Java一样，JavaScript也可以用关键字 `this` 来指代当前的Object：\n\n> Note that the manner in which the `this` variable is assigned can lead to some subtle errors when using callback functions. For more details, see [the chapter on ES6 features](https://info340.github.io/es6.html#es6). \n\n```js\n// An object representing a Dog\nlet fido = {\n  name: \"Fido\",\n  bark: function() { console.log(this.name, \"woofs\")}\n}\n\n// An object representing another Dog\nlet spot = {\n  name: \"Spot\",\n  bark: function() { console.log(this.name, \"yips\")}\n}\n\nconsole.log('***This is Fido barking:***');\nfido.bark(); //=> \"Fido woofs\". Note, `this` will refer to the `fido` object.\n\nconsole.log('***This is Spot barking***');\nspot.bark(); //=> \"Spot yips\". Note, `this` will refer to the `spot` object.\n```\n\n\n\n### 回调函数\n\n函数也可以被作为参数传递给其它函数：\n\n```js\n//create a function `sayHello`\nfunction sayHello(name){\n    console.log(\"Hello, \"+name);\n}\n\n//a function that takes ANOTHER FUNCTION as an argument\n//this function will call the argument function, passing it \"world\"\nfunction doWithWorld(funcToCall){\n    //call the given function with an argument of \"world\"\n    funcToCall(\"world\");\n}\n\ndoWithWorld(sayHello);  //logs \"Hello world\";\n```\n\n被当做变量传递给另一个函数的函数叫做：回调函数。因为被当成参数的函数只有在需要的时候才会被\"call back\"叫出来干活。\n\n```js\nfunction doLater(callback) {\n    console.log(\"I'm waiting a bit...\");\n    console.log(\"Okay, time to work!\");\n    callback();  //\"call back\" and execute that function\n}\n\nfunction doHomework() {\n    // ...\n};\n\ndoLater(doHomework);\n```\n\n\n\n将函数作为参数传递给其他函数的概念是函数式编程的核心，也是赋予其表达力的关键：我们可以主要通过运行的行为来定义程序行为，而不是过多地关注使用的数据变量。此外，回调函数对于支持交互至关重要：许多内置的JavaScript函数接受一个回调函数，该函数指定在某个特定时间发生时应该执行什么操作（例如，当用户点击按钮时）。\n\n\n\n通常回调函数在被定义后只会被单个函数使用，因此我们可以直接以匿名函数的形式来创建回调函数：\n\n```js\n//name anonymous function by assigning to variable\nlet sayHello = function(name){\n    console.log(\"Hello, \"+name);\n}\n\nfunction doWithWorld(funcToCall){\n    funcToCall(\"world\");\n}\n\n//法1：pass the named function by name\ndoWithWorld(sayHello);\n\n//法2：pass in anonymous version of the function\ndoWithWorld(function(name){\n    console.log(\"Hello, \"+name);\n});\n```\n\n- 注意，使用匿名函数时，`}`  和 `)` 的位置！\n\n\n\n### 闭包\n\n我们不仅仅可以将函数作为参数传递，还可以将函数作为参数返回！\n\n看下面这个例子：\n\n```js\n//This function produces ANOTHER FUNCTION\n//which greets a person with a given greeting\nfunction makeGreeterFunc(greeting){\n    //explicitly store the param as a local variable (for clarity)\n    let localGreeting = greeting;\n\n    //A new function that uses the `greeting` param\n    //this is just a value!\n    let aGreeterFunc = function(name){\n        console.log(localGreeting+\" \"+name);\n    }\n\n    return aGreeterFunc; //return the value (which happens to be a function)\n}\n\n//Use the \"maker\" to create two new functions\nlet sayHello = makeGreeterFunc('Hello'); //says 'Hello' to a name\nlet sayHowdy = makeGreeterFunc('Howdy'); //says 'Howdy' to a name\n\n//call the functions that were made\nsayHello('world'); //\"Hello world\"\nsayHello('Dave'); //\"Hello Dave\"\nsayHowdy('world'); //\"Howdy wold\"\nsayHowdy('partner'); //\"Howdy partner\"\n```\n\n通过将不同的参数传入 `makeGreetFunc()` , 我们可以创建自定义招呼方式的函数。\n\n可以发现，在 `makeGreetFunc()` 函数里的变量 `localGreeting` 被传递给了返回的函数 `aGreetFunc()` ，并且在`makeGreetFunc()` 返回后，在其的scope之外仍可被访问。\n\n这就是**闭包**，在JavaScript里可以用这个特性来在变量里存储数据。在异步编程 [Asynchronous Programming](https://info340.github.io/ajax.html#ajax)时，这个特性也非常有用。\n\n\n\n### 函数式循环\n\n在 `ES5` 中，JavaScript引入了函数式编程的概念。\n\n#### forEach()\n\n使用 [`forEach()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) 可以方便地遍历数组中的元素并使用参数中的回调函数对每个元素做点什么，比如：\n\n```js\nlet arr = [{...}, {...}, {...}];\n\n//function for what to do with each item\nfunction printItem(currentItem){\n    console.log(currentItem;)\n}\n\n//print out each item\narr.forEach(printItem);\n```\n\n`forEach()` 的回调函数 `callbackFn()` 至多可以有三个参数：\n\n- [`element`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#element)\n\n  The current element being processed in the array.\n\n- [`index`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#index)\n\n  The index of the current element being processed in the array.\n\n- [`array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#array)\n\n  The array `forEach()` was called upon.\n\n\n\n`forEach()` 的回调函数一般都使用匿名函数来定义。\n\n\n\n- `forEach()` is a *built-in* method for Arrays—similar to `push()` or `indexOf()`. For reference, the “implementation” of the `forEach()` function looks something like:\n\n  ```js\n  Array.forEach = function(callback) { //define the Array's forEach method\n      for(let i=0; i<this.length; i++) {\n          callback(this[i], i, this);\n      }\n  }\n  ```\n\n  In effect, the method does the job of managing the loop and the loop control variable for you, allowing you to just focus on what you want to do for each item.\n\n#### map()\n\n如果你想要对原数组的所有元素进行一定的变换，然后得到一个含有变换后的元素的新数组，比如：\n\n```js\nlet arr1 = [1, 2, 3, 4, 5];\n//将arr1的元素的平方映射到square\nlet square = [1, 4, 9, 16, 25];\n```\n\n使用 `map()` 方法：\n\n```js\nlet numbers = [1,2,3,4,5];  //an initial array\nlet squares = numbers.map(function(item){\n    return item*item;\n});\n```\n\n同样的，map方法的回调函数也有最多三个参数：element、index、array。\n\n#### filter()\n\n还有一种常用的方法是过滤掉不要的元素，比如：\n\n```js\nlet arr = [1, 2, 3 ,4, 5];\n//只要偶数\nlet evens = [2, 4];\n```\n\n使用 `filter()` 方法来实现：\n\n```js\nlet arr = [1, 2, 3, 4, 5];\n\nlet evens = arr.filter(function(n) {\n    return (n%2 == 0);\n});\n```\n\n**注意：** `filter()` 方法的回调函数 `callbackFn()` 只能返回 `true` 或 `false` ，且其回调函数的参数和 `forEach()` 一样。\n\n##### 串联函数\n\n因为 `map()` 和 `filter()` 返回的都是一个数组，所以可以把它们串起来使用：\n\n```js\nlet arr = [1, 2, 3, 4, 5, 6];\n\nfunction isEven(element) {\n    return (element%2 == 0);\n}\n\nfunction square(n) {\n    return n*n;\n}\n\nlet sqEvens = arr.filter(isEven).map(square); //[4, 16, 36]\n```\n\n\n\n#### reduce()\n\n[**`reduce()`**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) 方法让你能够将数组内的每个元素相互结合成一个单值，比如累加/乘等等。\n\n**`reduce()` 需要1个或2个参数，它的回调函数 `callbackFn()` 也要至少2个，最多4个参数：**\n\n> [`callbackFn`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#callbackfn)\n>\n> 为数组中每个元素执行的函数。其返回值将作为下一次调用 `callbackFn` 时的 `accumulator` 参数。对于最后一次调用，返回值将作为 `reduce()` 的返回值。该函数被调用时将传入以下参数：\n>\n> - [`accumulator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#accumulator)\n>\n>   上一次调用 `callbackFn` 的结果。在第一次调用时，如果指定了 `initialValue` 则为指定的值，否则为 `array[0]` 的值。\n>\n> - [`currentValue`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#currentvalue)\n>\n>   当前元素的值。在第一次调用时，如果指定了 `initialValue`，则为 `array[0]` 的值，否则为 `array[1]`。\n>\n> - [`currentIndex`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#currentindex)\n>\n>   `currentValue` 在数组中的索引位置。在第一次调用时，如果指定了 `initialValue` 则为 `0`，否则为 `1`。\n>\n> - [`array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#array)\n>\n>   调用了 `reduce()` 的数组本身。\n>\n> [`initialValue`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#initialvalue) 可选\n>\n> 第一次调用回调时初始化 `accumulator` 的值。如果指定了 `initialValue`，则 `callbackFn` 从数组中的第一个值作为 `currentValue` 开始执行。如果没有指定 `initialValue`，则 `accumulator` 初始化为数组中的第一个值，并且 `callbackFn` 从数组中的第二个值作为 `currentValue` 开始执行。在这种情况下，如果数组为空（没有第一个值可以作为 `accumulator` 返回），则会抛出错误。\n\n```js\nfunction add(x, y) { //a function that adds two numbers\n    return x+y;\n}\n\nlet numbers = [1,2,3,4,5];  //an initial array\n\nlet sum = numbers.reduce(add);\nconsole.log(sum); //15\n```\n\n`reduce()` 使用两个参数的情况：\n\n```js\n//sum starting from 10\nlet sum = numbers.reduce(add, 10);\n\n//或者：\n\n//sum starting from 10\nnumbers.reduce(function(x, y){\n    return x+y;\n}, 10); //the starting value comes AFTER the callback!\n```\n\nTo summarize：\n\n![](../img/JavaScript/Map-filter-reduce.png)\n\n\n\n\n"},{"title":"CSS笔记","url":"/CSS笔记/","content":"# CSS\n参考：[Client-Side Web Development](https://info340.github.io/css.html)\n## 一、覆盖规则\n\n同级的选择器的同一个属性，谁最后渲染谁生效；\n\n不同级的选择器，最具体的（比如#id比.class具体）优先级最高。\n\n## 二、 复合选择器\n\n### 多个选择器组合\n\n```css\n/* can also include class or id selectors */\n/* this rule applies to h2 elements, \"menu\" classed elements, and the\n   #sidebar element */\nh2, .menu, #sidebar {\n    background-color: gray;\n}\n```\n\n> since later rules take precedence earlier ones, you can use a group select to apply a property to multiple different elements, then include additional rules to add variations.\n\n### 组合选择器\n\n```css\n/* Selects only p elements that have class=\"alert\"\n   Other p elements and \"alert\" classed elements not affected */\np.alert {\n  color: red;\n}\n\n/* Selects only h1 elements that have id=\"title\" */\n/* Note that this is redundant, since only one element can have the id! */\nh1#title {\n  color: purple;\n}\n\n/* Selects elements that have class \"alert\" AND class \"success\" */\n.alert.success {\n  color: green;\n  font-size: larger;\n}\n\n/* And can combine with group selector */\n/* applies to <p class=\"highlighted\"> and <li class=\"selected\"> */\np.highlighted, li.marked {\n  background-color: yellow;\n}\n```\n\n\n\n### 后代选择器\n\n在父选择器后加空格。所有直接和间接的后代都生效。\n\n```html\n<header>\n   <h1>Welcome to the page</h1>\n   <p>I am a special paragraph</p>\n</header>\n<section>\n   <p>some other paragraph</p>\n</section>\n```\n\n```css\n/*\n  Selects p elements that exist within header elements\n  Other p elements will not be affected\n */\nheader p {\n    /* ... */\n}\n```\n\n​\t如果嵌套大于3层时，建议改用.class选择器。\n\n### 子类选择器\n\n只会选择直系的子元素。\n\n```css\n/* Selects paragraph \"Body content\" (immediate child of body),\n   not paragraph \"Section content\" (immediate child of section) */\nbody > p {\n  color: blue;\n}\n```\n\n\n\n### 伪类选择器\n\n在基本选择器后加 `:` 。\n\n```css\n/* style for unvisited links */\na:link { /*...*/ }\n\n/* style for visited links */\na:visited { /*...*/ }\n\n/* style for links the user is hovering over with the mouse */\na:hover { /*...*/ }\n\n/* style for links that have keyboard focus */\na:focus { /*...*/ }\n\n/* style for links as they are being 'activated' (clicked) */\na:active { /*...*/ }\n```\n\n记住：\n\n`a:hover` 必须跟在 `a:link` 之后；\n\n`a:visited` 和 `a:active`必须跟在 `a:hover` 之后；\n\n为了支持只用键盘的人，请同时使用  `a:hover` 和 `a:focus`\n\n> Note that there are [many additional pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes), including ones that consider specific element attributes (e.g., if a checkbox is `:checked`) or where an element is located within its parent (e.g., if it is the `:first` or `:last-child`, which can be useful for styling lists).\n\n#### nth-* 选择器\n\n`nth-child`  and `nth-of-type`\n\n区别：\n\n```css\n/* 只选中第二个p元素 */\np:nth-of-type(2) {\n    color:red;\n}\n\n/* 只选中第二个元素，但如果第二个元素不是p，那么就不会生效 */\np:nth-child(2) {\n    color:red;\n}\n```\n\n[这里](https://css-tricks.com/the-difference-between-nth-child-and-nth-of-type/)建议使用 `nth-child()` 的时候结合后代选择器使用，而不要说明具体对应的类：\n\n```css\ndl :nth-child(2) {  } /* is better than */\ndd:nth-child(2) {  } /* this */\n```\n\n\n\n>  don’t forget about the awesome cousins `:first-of-type`, `:last-of-type`, `:nth-last-of-type` and `:only-of-type`. [Learn more here.](https://css-tricks.com/pseudo-class-selectors/)\n\n\n\nThe `nth-*` selectors also support the keywords `odd` and `even`, which is really useful for styling tables:\n\n```css\n/* Give every-other row a light-gray background */\ntr:nth-of-type(even) {\n  background-color:#eee;\n}\n```\n\n### 属性选择器\n\n最经常用来给表格进行美化。\n\n```css\n/* select <input type=\"checkbox\"> that have the \"checked\" state */\ninput[type=checkbox]:checked {\n    color: green;\n}\n```\n\nIt is also possible to select attributes that only “partially” match a particular value; see the documentation for details.\n\n\n\n## 三、属性值\n\n### 单位&大小\n\n字体尽量使用相对单位，布局参数可能为绝对单位，但相对单位是最好的：\n\n| Unit       | Meaning                                                      |\n| ---------- | ------------------------------------------------------------ |\n| `em`       | Relative to the **current** element’s font-size. Although originally a [typographic measurement](http://en.wikipedia.org/wiki/Em_(typography)), this unit will **not** change based on `font-family`. |\n| `%`        | Relative to the **parent** element’s font-size *or* dimension. For font-size, use `em` instead (e.g., `1.5em` is `150%` the parent font-size). |\n| `rem`      | Relative to the **root** element’s font-size (i.e., the `font-size` of the root `html` or `body` element). This will often be more consistent than `em`. |\n| `vw`, `vh` | Relative to the **viewport** (e.g., the browser window). Represents 1% of the viewport width and height, respectively. This unit is not supported [by older browsers](http://caniuse.com/#search=vw). |\n\n一般默认的em是16px，即 `1em` 和 `1rem` 等于 `16px`。\n\n### 颜色\n\n有141种内置的颜色，见[predefined color names](http://www.w3schools.com/cssref/css_colornames.asp)。\n\n```css\np {\n   color: mediumpurple;\n}\n\np {\n   color: rgb(147, 112, 219); /* medium purple */\n}\n\np {\n   background-color: rgba(0,0,0,0.5); /* semi-transparent black */\n}\n\np {\n   color: #9370db; /* medium purple */\n}\n```\n\n- 历史趣闻：The list of CSS color names also has a [fascinating history](http://arstechnica.com/information-technology/2015/10/tomato-versus-ff6347-the-tragicomic-history-of-css-color-names/).\n\n### 字体&图标\n\n```css\np {\n    font-family: 'Helvetica Nue', 'Helvetica', 'Arial', sans-serif;\n}\n```\n\n使用font-family属性指定字体，注意最后一个字体必须为通用字体，These are a list of “categories” that the browser can draw upon even if the computer doesn’t have any common fonts available. In pracice, the most common generic families used are `serif` (fonts with [serifs](https://en.wikipedia.org/wiki/Serif), e.g., “Times”), `sans-serif` (fonts *without* serifs, e.g., “Arial”), and `monospace` (fonts with [equal width characters](https://en.wikipedia.org/wiki/Monospaced_font), e.g., “Courier”).\n\n你也可以在自己的网页上包含特殊的字体，以防客户没有这种字体。比如，使用 Google fonts:\n\n```html\n<head>\n    <!-- ... -->\n\n    <!-- load stylesheet with font first so it is available -->\n    <link href=\"https://fonts.googleapis.com/css?family=Encode+Sans\" rel=\"stylesheet\">\n\n    <!-- load stylesheet next -->\n    <link href=\"css/style.css\" rel=\"stylesheet\">\n</head>\n```\n\n```css\nbody {\n    font-family: 'Encode Sans', sans-serif; /* can now use Encode Sans */\n}\n```\n\n**注意：**如果你希望在使用Google Fonts的同时使用Bold，Italic等类型，你需要在引用里额外说明，否则不会生效：\n\n```html\n<!-- includes normal (400) and bold (700) weights -->\n<link href=\"https://fonts.googleapis.com/css?family=Encode+Sans:400,700\" rel=\"stylesheet\">\n```\n\n\n\n你也可以用类似的方法引入图标，比如font awesome：\n\n```html\n<link href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\" rel=\"stylesheet\">\n```\n\n> This will load the stylesheet from a [Content Delivery Network (CDN)](https://en.wikipedia.org/wiki/Content_delivery_network), which is a web service intended to quickly serve files commonly used by multiple websites. In particular, browsers will *cache* (save) copies of these files locally, so that when you visit a different website (or the same website for a second time), the file will already be downloaded. We will load most of the CSS and JavaScript frameworks used in this class from a CDN.\n\n使用font awesome：\n\n```html\n<i class=\"fa fa-universal-access\" aria-hidden=\"true\"></i>\n```\n\n**记得加上 `aria-hidden=\"true\"` 来增加Accessibility，使屏幕阅读器不会读出这些图标奇怪的名字！**\n\n\n\n### 背景&图片\n\n插入背景图片：\n\n```css\nheader {\n    background-image: url('../img/page-banner.png');\n}\n```\n\n关于背景，有一堆属性：\n\n```css\nheader {\n    background-image: url('../img/page-banner.png');\n    background-position: center top; /* align to center top */\n    background-size: cover; /* stretch so element is filled; preserves ratio (img may be cropped) */\n    background-repeat: no-repeat; /* don't repeat */\n    background-attachment: fixed; /* stay still when window scrolls */\n    background-color: beige; /* can still have this for anything the image doesn't cover\n                                (or for transparent images) */\n}\n```\n\n简写：\n\n```css\nheader {\n    background: url('../img/page-banner.png') top center / cover no-repeat fixed beige;\n}\n```\n\n- The `background-position` and `background-size` are separated by a `/` since they both can have more than one value.\n\n- You can include some or all of the available background properties in the shorthand. Unlike most shorthand properties, the `background` properties can go in any order (though the above is recommended).\n\n注意，简写会用它所包含的属性覆写掉之前定义过的对应属性。\n\n`background` 属性也支持使用逗号隔开的多层背景（[multiple backgrounds](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Background_and_Borders/Using_CSS_multiple_backgrounds)），你可以利用这个特点来重叠透明背景，就像Photoshop那样。\n\n\n\n## 四、布局\n\n以左上角为原点，元素依次排列。遵循下列三个概念：\n\n- Display：确定元素怎样共享水平空间\n- Position：调整元素的位置\n- Box-model：决定元素占据的2维空间，以及元素之间的间隔空间\n\n### Display\n\n- 行内元素\n- 块元素\n\n可以使用 `display` 属性控制元素成为行内元素还是块元素：\n\n```css\n.inlined {\n  display: inline;\n}\n```\n\n```html\n<!-- this will produce the same result as using <span> elements -->\n<div class=\"inlined\">Inline element</div>\n<div class=\"inlined\">Other inline element</div>\n```\n\n\n\n如果你想将某个元素从页面中移除：\n\n```css\n.hidden {\n    display: none;\n}\n```\n\n\n\n你也可以设置 `display: inline-block` ，这个属性让元素表现为行内元素，但允许元素使用 `width` ，`height` 等属性，就像块元素一样。\n\n> This is particularly useful for making things like lists (`<ul>`) appear “inline”.\n\n\n\n### 盒子模型\n\n所有元素都像是被装在一个盒子里一样，这个盒子包括4个部分：\n\n- 内容\n- padding\n- border\n- margin\n\n你也可以单独设置 `height` 和 `width` 属性，但是建议只设置其中一个，以免设置不当使内容被裁剪（由 `overflow` 属性控制）。你也可以设置 `min-width` ，`min-height`，`max-width`，`max-height` 属性来指定最大最小值。\n\n#### Padding\n\npadding是内容和border之间的间距。\n\n```css\n/* specify each side individually */\ndiv {\n  padding-top: 1em;\n  padding-bottom: 1em;\n  padding-left: 2em;\n  padding-right: 0; /* no units needed on 0 */\n}\n\n/* specify one value for all sides at once */\ndiv {\n  padding: 1.5em;\n}\n\n/* specify one value for top/bottom (first)\n   and one for left/right (second) */\ndiv {\n  padding: 1em 2em;\n}\n```\n\n\n\n#### Border\n\n边框有许多属性，比如 width、color、radius、style等等。\n\n```css\n.boxed {\n   border: 2px dashed black; /* border on all sides */\n}\n\n.underlined {\n   border-bottom: 1px solid red; /* border one side */\n}\n\n.something { /* control border properties separately */\n   border-top-width: 4px;\n   border-top-color: blue;\n   border-top-style: dotted;\n   border-radius: 4px; /* rounded corners! */\n}\n```\n\n\n\n#### Margin\n\nMargin决定了当前盒子和旁边其他盒子之间的间距，定义margin的方式和padding非常相似。\n\n**注意：** 相近元素的Margin通常会互相 [collapse](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing) (overlap)，比如上方元素的 `margin-bottom` 会和下方元素的 `margin-top` 重叠，取二者之间更大的那个作为它们之间的间距。\n\n\n\n#### 盒子大小\n\n你盒子的大小应该为：\n\nwidth + padding + border = actual visible/rendered width of an element’s box\n\nheight + padding + border = actual visible/rendered height of an element’s box\n\n例：\n\n```css\n.my-box {\n    width: 100px;\n    padding: 10px; /* includes both left and right */\n}\n```\n\n上述盒子的宽度为120px。\n\n当使用响应式设计的时候，这种计算方法非常不方便，我们可以设置 `box-sizing` 属性为 `border-bpx` 来 “Reset” 所有元素，使得 `width` 属性包括 padding 和 border。\n\n```css\nhtml {\n  box-sizing: border-box;\n}\n*, *:before, *:after {\n  box-sizing: inherit;\n}\n```\n\n见：https://css-tricks.com/box-sizing/\n\n\n\n### Position\n\ndisplay只能改变盒子的形状，要改变盒子的位置，使用position属性。\n\nposition有4个数值：\n\n- `static` ：默认数值，就是默认的布局。此时，`top`、`bottom` 、`left` 和 `right` 属性不起作用。\n- `relative` : 你可以使用`top`、`bottom` 、`left` 和 `right` 这些属性指定元素对于其页面中的自然位置的位移。\n- `fixed` ：使元素不随滚动条移动而始终保持在相对浏览器视窗中的某个位置。用`top`、`bottom` 、`left` 和 `right` 设置。\n- `absolute` ：设定元素对于其首个非 `static` 的父元素的相对位移。**注意：**要使用 `absolute` 属性，最好要把父元素设置为 `position: relative`。See [this post](https://css-tricks.com/absolute-positioning-inside-relative-positioning/) for more information.\n\n\n\nIn order to specify the location for a **`fixed`** element, use the `top`, `left`, `bottom`, and/or `right` properties to specify distance from the appropriate edge of the browser window:\n\n```css\n/* make the <nav> element fixed at the top of the browser window */\nnav {\n    position: fixed;\n    top: 0;  /* 0px from the top */\n    left: 0; /* 0px from the left */\n    width: 100%; /* same as parent, useful for spanning the page */\n}\n```\n\n### Floating\n\n你也可以使用float来移动元素的位置。float的元素会安于屏幕的一隅，而其他内容会将其wrap起来。\n\n如果你不想要其他内容wrap在float元素的周围，可以使用 `clear` 属性：\n\n```css\n.clear-float {\n    clear: both; /* do not allow floating elements on either side */\n}\n```\n\n\n\n**注意：**如果你只是想让某个元素安于页面一隅，你可以使用float。但更复杂的布局（比如多栏目结构）则需要更好的方法来实现。\n\n\n\n### Flexbox\n\n> Flexbox is a new standard that is now supported by [most modern browsers](http://caniuse.com/#feat=flexbox); it has a buggy implementation in Microsoft IE, but is supported in the standards-compliant Edge. For older browsers, you can instead rely on a grid system from one of the popular CSS Frameworks such as Bootstrap.\n\n\n\n> Despite it’s capabilities, Flexbox still is designed primarily for one-directional flows (e.g., having one row of columns). To handle true grid-like layouts, browsers are adopting *another* emerging standard called [**Grid**](https://css-tricks.com/snippets/css/complete-guide-grid/). The Grid framework shares some conceptual similarities to Flexbox (configuring child elements inside of a parent container), but utilizes a different set of properties. Learning one should make it easy to pick up the other. Note that the grid framework is [less well supported](http://caniuse.com/#search=CSS grid) than even Flexbox (it is not supported by IE, Edge, or common older Android devices), so should be used with caution.\n\n\n\n要使用flexbox，你需要一个容器元素来装载子元素：\n\n```html\n<div class=\"flex-container\"> <!-- Parent -->\n  <div class=\"flex-item\">Child 1</div>\n  <div class=\"flex-item\">Child 2</div>\n  <div class=\"flex-item\">Child 3</div>\n</div>\n```\n\n把容器元素设置为：\n\n```css\n.flex-container { /* my flexbox container class */\n    display: flex;\n}\n```\n\nflexbox默认是水平排列的，你可以修改容器元素的 `flex-direction` 属性来调整。见：[flex-direction](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-3)\n\n除了 `height` 和 `width` 以外，flexbox有更加灵活的方式来设置这些属性：\n\n所有flexbox容器的直接子元素都可以使用相关的属性来改变它们在flexbox容器中的排列方式，下面是三个主要的属性：\n\n```css\n* { box-sizing: border-box; } /* recommended for item sizing */\n\n.flex-item {\n    flex-grow: 1; /* get 1 share of extra space */\n    flex-shrink: 0; /* do not shrink if items overflow container */\n    flex-basis: 33%; /* take up 33% of parent initially */\n}\n```\n\n- [**`flex-grow`**](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-10) 指定了额外的空间如何在子元素之间分配。\n\n  > That is, if the container is `500px` wide, but the items’ only takes up `400px` of space, this property determines how much of the remaining `100px` is given to the item.\n\n  > The value is a unitless number (e.g., `1` or `2`, defaulting to `0`), and the amount of remaining space is divided up *proportionally* among the items with a `flex-grow`. So an item with `flex-grow:2` will get twice as much of the remaining space as an item with `flex-grow:1`. If there are 4 items and `100px` of space remaining, giving each item `flex-grow:1` will cause each item to get `25px` (100/4) of the extra space. If one of the items has `flex-grow:2`, then it will get `40px` (21+1+1+2=25=40%21+1+1+2=25=40%) of the extra space, while the other three will only get `20px`.\n\n  可以使用 `flex-grow:1` 让所有子元素在容器中均匀分布。.\n\n- [**`flex-shrink`**](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-11) works similar to `flex-grow`, but in reverse. It takes as a value a number (default to `1`), which determine what “share” or ratio it should shrink by in order to accommodate any overflow space. If the specified dimensions of the items exceeds the dimensions of the container (e.g., 4 `100px` items in a `300px` container would have `100px` of “overflow”), the `flex-shrink` factor indicates how much size needs to be “taken off” the item. A higher number indicates a greater amount of shrinkage.\n\n  In practice, you will often leave this property at default (by not specifying it), *except* when you want to make sure that an item does NOT shrink by giving it `flex-shrink:0`.\n\n- [**`flex-basis`**](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-12) allows you to specify the “initial” dimensions of a particular item. This is similar in concept to the `width` property, except that `flex-basis` is more [flexible](https://stackoverflow.com/questions/34352140/what-are-the-differences-between-flex-basis-and-width) (e.g., if you change the `flex-direction` you don’t also have to change from `width` to `height`). Note that this value can be an dimensional measurement (absolute units like `100px`, or a relative unit like `25%`).\n\n\n\n你也可以使用简写：`flex` 来指定上述3个属性：\n\n> give the `flex-grow`, `flex-shrink`, and `flex-basis` values separated by spaces (the second two being optional if you want to use the default values). Note that if unspecified, the `flex-basis` property will be set to `0`, rather than the `auto` value it has if unspecified.\n\n\n\n除此之外，容器中还可以使用这些元素来进行布局：\n\n> The Flexbox framework also provides a number of additional properties that you can specify on the **container** to customize how items of different sizes are organized on the screen:\n>\n> - [`justify-content`](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-6) specifies how the items should be spread out across the container. Note that items that have `flex-grow:1` will use up the extra space, making this less relevant.\n> - [`align-items`](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-7) is used to specify “cross-axis” alignment (e.g., the vertical alignment of items for a horizontal row).\n> - [`flex-wrap`](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-4) is used to have items “wrap around” to the next line when they overflow the container *instead of* shrinking to fit. You can then use the [`align-content`](https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-8) property to specify how these “rows” should be aligned within the container.\n>\n> While it may seem like a lot of options, Flexbox layouts will allow you to easily create layouts (such as multi-column pages) that are otherwise very difficult with the regular box model. Moreover, these layouts will be flexible, and can easily be made **responsive** for different devices and screen sizes.\n\n\n\n## 五、响应式设计\n\n### 移动设备优先\n\n为了进行更好的适配，我们优先适配屏幕受限最大的移动式设备。之后，我们可以通过“who comes last wins”的CSS规则对更大屏幕的设备进行适配，并在移动式设备的基础上增加更多效果。\n\n原则：\n\n- Layout：移动设备的页面布局应采用上下堆叠式布局，追求只需在垂直轴上下移动浏览。position属性为`fixed` 的元素应该尽可能少，以节省被占据的空间。\n- Media：小尺寸屏幕需要的图片不需要太高的分辨率，同时，降低分辨率或者压缩媒体文件也可以节省加载时间。（大屏幕的设备带宽一般更足，所以可以使用高分辨率的媒体文件）\n- Font：使用**相对字体单位**来适配移动设备。\n- Navigation：太大的Navigation可能会因为wrapping到多行。建议使用小tab bar，或者菜单图标或者使其collapse来减少空间。\n- 输入和互动：可点击和互动的元素要足够大。不要使用拥挤在一块的小图标和非常短的超链接。\n- 内容：对于移动端和网页端用户，使用不同的方式表示同样的内容：比如在移动端显示一个巨大的电话图标，而在网页端直接显示电话号码。\n\n### 指定Viewport\n\n有的时候移动端浏览器会自动缩放网页内容来进行适配，但这有时候会导致内容太小，用户不得不再次手动放大。\n\n说明viewport的size和scale可以避免这种问题。在html里面使用下列 `<meta>` 标签：\n\n```html\n<head>\n  <meta charset=\"utf-8\"> <!-- always need this -->\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n\n  <!-- more head elements, including <link> ... -->\n</head>\n```\n\n一般我们指定3个属性：\n\n- `width` ：指明设备的屏幕宽度（viewport）\n- `initial-scale` ：初始页面的缩放值，一般为1，即不缩放\n- `shrink-to-fit`：告诉浏览器不要缩放内容来进行适配\n\n更多详见：[Viewport](https://developer.mozilla.org/en-US/docs/Glossary/Viewport)\n\n### Media Queries\n\n使用媒体查询来构建响应式设计。\n\n媒体查询有点类似 `if` 语句。\n\n```css\n/* A normal CSS rule, will apply to all screen sizes */\nbody {\n    font-size: 14px;\n}\n\n/* A Media Query */\n@media (min-width: 768px)\n{\n    /* these rules apply ONLY on screens 768px and wider */\n\n    /* a normal CSS rule */\n    body {\n        font-size: 18px;\n        background-color: beige;\n    }\n    /* another CSS rule */\n    .mobile-call-icon {\n        display: none; /* don't show on large displays */\n    }\n}\n```\n\n格式就是 `@media ( expression ) { }` ，其中expression表示条件，`min-width: 768px` 表示viewport的width大于等于768px时生效，`max-width` 类似。\n\n如果要使用与或非逻辑：\n\n- `and` 和 `not` 表示与和非\n- 用逗号隔开的规则表示或\n\n```css\n/* style rules for screens between 768px and 992px */\n@media (min-width: 768px) and (max-width: 992px) { }\n\n/* style rules for screens larger than 700px OR in landscape orientation */\n@media (min-width: 700px), (orientation: landscape) { }\n```\n\n\n\n采用 Mobile First 的设计理念，我们把适配移动设备的规则放在最上方，然后在媒体查询里写针对大屏设备的规则来覆盖它们：\n\n```css\n/* on small mobile devices, the header has a purple background */\nheader {\n    font-size: 1.2rem;\n    background-color: mediumpurple;\n}\n\n/* on 768px OR LARGER displays */\n@media (min-width: 768px) {\n    header {\n        font-size: 1.5rem; /* make the header larger font on larger displays */\n    }\n}\n\n/* on 992px OR LARGER displays */\n@media (min-width: 992px) {\n    header {\n        background-image: url('../img/banner.png') /* use background image */\n    }\n}\n```\n\n#### Flexbox案例\n\n```html\n<div class=\"row\">\n  <div class=\"column\">column ONE content</div>\n  <div class=\"column\">column TWO content</div>\n  <div class=\"column\">column THREE content</div>\n  <div class=\"column\">column FOUR content</div>\n</div>\n```\n\n```css\n/* on devices 768px OR WIDER */\n@media (min-width: 768px)\n{\n    .row { /* row is a flexbox container */\n        display: flex;\n        flex-wrap: wrap; /* wrap extra items to the next \"line\" */\n    }\n\n    .column  { /* column is a flexbox item */\n        flex-basis: 50%; /* columns take up 50% of parent by default */\n        flex-grow: 1;\n    }\n}\n\n@media (min-width: 1200px) {\n    .column {\n        flex-basis: auto; /* columns are automatically sized based on content */\n    }\n}\n```\n\nCodePen演示：[Flexbox响应式设计](https://codepen.io/joelross/pen/YxvBzG)\n\n## 六、CSS Framework\n\n你可以使用现成的CSS框架来构建网页，而省去自己完全从0开始书写CSS的麻烦。\n\n一些框架：\n\n- [**Bootstrap**](http://getbootstrap.com/)\n- [**Foundation**](http://foundation.zurb.com/)\n- [**Material Components for the Web (MCW)**](https://material.io/components/web/)\n- [**normalize.css**](http://necolas.github.io/normalize.css/)：If you choose **not** to use a framework, you should still include `normalize` to make your sites consistent across browsers!\n\n### 使用框架\n\n使用 `<link>` 标签来引入框架。\n\n```html\n<head>\n  <!--... other elements here...-->\n\n  <link rel=\"stylesheet\"\n        href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css\">\n  <link rel=\"stylesheet\" href=\"css/my-style.css\">\n</head>\n```\n\n**注意：**请在你自己的css之前引入框架，这样你自己写的CSS才不会被覆盖。\n\n\n\n你可以使用CDN来引入CSS：\n\n> You can almost always switch between the minimized and non-minimized file just by changing the file name between `file.css` and `file.min.css` (when using a CDN).\n\n或者，直接下载源代码到本地路径，然后通过相对路径引入。\n\n你也可以使用**包管理器** ，比如`npm`来下载CSS框架：\n\n```bash\n# install bootstrap (latest version)\nnpm install bootstrap\n```\n\n> This will install the library’s source code into your project’s `node_modules/` folder. Because you’ve saved the dependency in your `package.json` file, you can use the `.gitignore` file to exclude the `node_modules/` folder from your code repo, having new developers install the required framework via `npm install`. You can also use `npm` to easily upgrade the packages (such as when a new version of Bootstrap comes out.\n\n### Bootstrap\n\n使用Bootstrap框架。\n\n引入：\n\n```html\n<link rel=\"stylesheet\"\n      href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css\"\n      integrity=\"sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65\"\n      crossorigin=\"anonymous\">\n```\n\n> (This `<link>` example has 2 additional (optional) attributes: `integrity` gives a [cryptographic hash](https://en.wikipedia.org/wiki/Cryptographic_hash_function) of the source code so the browser can make sure you didn’t download a malicious file by mistake, and `crossorigin` which says that no credentials are sent to the remote server—see the [AJAX](https://info340.github.io/ajax.html#ajax) chapter for a more detailed discussion).\n\n你可以使用特殊的class名来给html元素引入Bootstrap的CSS效果：\n\n```html\n<button>Plain button</button>\n<button class=\"btn\">Bootstrap button</button>\n<button class=\"btn btn-primary\">Primary colored button</button>\n```\n\n它也支持响应式设计：\n\n| Screen Width | Abbreviation | Approximate Device Size                     |\n| ------------ | ------------ | ------------------------------------------- |\n| < 576px      | (default)    | Extra-small devices (e.g., portrait phones) |\n| ≥ 576px      | `sm`         | Small devices (e.g., landscape phones)      |\n| ≥ 768px      | `md`         | Medium devices (e.g., tablets)              |\n| ≥ 992px      | `lg`         | Large devices (e.g., laptops)               |\n| ≥ 1200px     | `xl`         | Extra-large devices (e.g., desktops)        |\n| ≥ 1400px     | `xxl`        | Extra-large devices (e.g., big desktops)    |\n\n使用方法：\n\n> the `float-md-left` class will cause the element to float **only on medium \\*or larger\\* screens**. Similarly, the `float-lg-left` class would cause the element to float only on *large or larger* screens.\n\n#### The Grid\n\n在Bootstrap里使用Grid来进行布局，`col-#` 表示元素占据此行的某个比例。下例中，Item 1占 6/12，Item 2 占 4/12，剩下的 2/12 被分配给Item 3。\n\n```html\n<div class=\"row\"> <!-- a row of items -->\n    <div class=\"col-6\">Item 1</div>\n    <div class=\"col-4\">Item 2</div>\n    <div class=\"col\">Item 3</div>\n</div>\n```\n\n响应式设计：\n\n```html\n<div class=\"row\">\n    <div class=\"col-sm-6 col-md-3\">Item 1</div>\n    <div class=\"col-sm-6 col-md-3\">Item 2</div>\n    <div class=\"col-sm-6 col-md-3\">Item 3</div>\n    <div class=\"col-sm-6 col-md-3\">Item 4</div>\n</div>\n```\n\n(See a [CodePen](https://codepen.io/drstearns/pen/XaYBXp) of this code in action!)\n\n#### 组件\n\nBootstrap还提供了很多组件，比如 `card` , `modal` , `navbar` 等等。\n\n有一些组件需要用到 Javascript，所以你要引入Bootstrap的JavaScript库：\n\n```html\n<!-- the Bootstrap JavaScript library -->\n<script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js\"></script>\n```\n\n然后你可以使用  `data-` 属性 (e.g., `data-thingamabob` or `data-my-attribute`) 来指定JavaScript的作用目标。\n\n```html\n<!-- note that the `id` attribute is set to \"exampleModal\" -->\n<div class=\"modal fade\" id=\"exampleModal\" tabindex=\"-1\" aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h1 class=\"modal-title fs-5\" id=\"exampleModalLabel\">Modal title</h1>\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n      </div>\n      <div class=\"modal-body\">\n        ...\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n        <button type=\"button\" class=\"btn btn-primary\">Save changes</button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!-- data-toggle must be set to \"modal\" and data-target must be set to\nthe value of the `id` attribute on the element that starts your modal markup -->\n<button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#exampleModal\">\n  Open the Modal\n</button>\n```\n\n注意上面例子中的modal的id是`exampleModal`，初始的时候是隐藏的，而只有一个button显示。\n\n这个button的 `data-bs-toggle=\"modal\"`，且指定这个Modal为：`data-bs-target=\"#exampleModal\"` 。\n\n这样，点击button的时候就会唤出id为 `exampleModal` 的modal。\n\nTry it out in [CodePen](https://codepen.io/drstearns/pen/dzKqNB).\n\n\n\n**注意：**CSS框架和javascript框架可能不兼容！\n\n> The JavaScript included in these CSS frameworks allows you to easily add interactive features, but **they do not mix well with more advanced JavaScript frameworks like React.** To work with React, you’d need to switch instead to a library such as [react-bootstrap](https://react-bootstrap.github.io/), which uses the Bootstrap CSS stylesheet, but re-implement the JavaScript portions to fit into the React framework.\n\n"},{"title":"《C陷阱与缺陷》笔记","url":"/[笔记]C陷阱与缺陷/","content":"# 声明变量与类型转换\n\n## 类型转换\n\n假如现在要声明一个 `float` 变量：\n\n```c\nfloat f;\n```\n\n那么当我们进行类型转换时，只要把_；_ 和 _变量名_ 去掉，并在类型外面加上_一对括号_ 即可：\n\n```c\n(float) a;\n```\n\n利用类型转换的原则，我们可以发现：\n\n```c\nfloat (*pf)();\n```\n\n声明了一个函数指针，由此，要把某个变量转换为函数指针：\n\n```c\n(float (*)())\n```\n\n现在你可以理解下列语句的意思了：\n\n```c\n(* (void (*)()) 0))();\n```\n\n我们也可以使用 `typedef` 来让这个语句看起来更漂亮一些：\n\n```c\ntypedef void (*funcptr)(); \n// 更准确的意思可以表达为： typedef void (*)() funcptr;\n// 但这不是正确的语法\n\n(*(funcptr) 0))();\n```\n\n但是，为什么不能使用：\n\n```c\ntypedef void (*)() funcptr;\n```\n\n呢？\n\n我猜原因是这里C语言应用的逻辑是 _声明_ 而不是 _类型转换_ . \n\n（尽管 `typedef void (*)() funcptr;` 这种写法更符合逻辑，也更易懂）\n\n对于一个函数，可以利用类似的思想来理解：\n\n```c\nfloat fun(...);\n```\n\n表示声明 `fun(...)` 是一个 `float` 类型的变量，即它的返回值是 `float` 类型的变量。\n\n而之所以在上面 `typedef` 的例子中要这么定义，同样也是和声明有关：\n\n```c\n// 下面是一个声明返回值为 void 的函数指针的声明方法\nvoid (*fun)(int);\n\n// 把 funcptr 作为 void (*)() 的别名时，需要使用声明的语法\ntypedef void (*funcptr)();\n// 同理：\ntypedef int uint32;\n```\n\n同样的，声明一个返回函数指针的函数时（以`signal()` 函数为例）：\n\n```c\n// 下面是一个声明返回值为 void 的函数指针的声明方法\nvoid (*fun)(int);\n\n// 由声明函数指针的方法知道我们要把signal这个函数的返回值声明为一个“返回值为 void 的函数指针”\n// 的方法：\n// 去掉变量名: void (*)(int)\n// signal的参数为一个int和一个函数指针，将 signal(int, void (*)(int)) 放进去\n\n// 应用规则，一个返回值为函数指针的函数应该声明为：\nvoid (*(signal(int, void (*)int)))(int);\n```\n\n\n\n# 语法陷阱\n\n## 指针和数组\n\n- C语言只有**一维数组**，且数组的大小在编译时必须为一个恒常数。而数组的成员可以为任意类型，包括数组，这使得构建多维数组成为可能。\n- 对数组只有两种操作：确定它的大小和获取第0个元素的指针。**所有**的数组操作都是通过指针完成的。所有的下标操作都相当于指针操作。\n\n- 除了作为关键字sizeof的操作数时，数组的变量名代表整个数组（因此返回的参数为数组的实际大小），其他时候都被转换为代表数组的首元素指针。ANSI C不允许 `p = &a` 这种写法，但在某些情况下 `&a` 代表“整个数组的地址”\n\n- 字符串：\n\n```c\n// 假定我们有字符串s和t\nchar *r;\nstrcpy(r, s);\nstrcat(r, t);\n```\n\n上面这种写法是错误的，因为不知道`r`指向何处，我们需要使用`malloc`或声明为`char r[100]`给`r`分配空间。\n\n- 数组作为参数传递时，实际上是传递了一个首元素的指针。\n- 逗号运算符：\n\n```c\n// 在函数参数中，逗号不是运算符\nfun(a, b);\n// 而当逗号作运算符的时候，逗号左边的值先运算，随后被丢弃\ng((a,b));\n```\n\n\n\n"},{"title":"Git使用笔记","url":"/git_note/","content":"# git配置\n\n`git config --global user.name \"...\"`\n\n`git config --global user.email\"...\"`\n\n# 使用git\n\n`git status`: 查看当前目录的文件状态\n\n`git init` :初始化仓库\n\n# 文件状态\n\n- 未跟踪\n\n- 已跟踪\n\n  - 暂存：文件已修改且保存，但还没有提交到git仓库\n  - 未修改\n  - 已修改\n\n  \n\n  刚刚添加到仓库的文件是未跟踪状态。\n\n  `git add 文件名` ：将文件从**未跟踪**切换到**暂存**的状态\n\n  `git add *`：将所有已修改 (未跟踪) 的文件暂存\n\n  `git add -u`：只对**已跟踪文件**有效，把所有已修改的已跟踪文件暂存\n\n  `git add -A`：把所有的变化（包括删除的和添加的文件）暂存\n\n  `git commit -m \"<message>\" `：将**暂存**的文件存到仓库里, message是本次提交的日志信息，状态变成 **未修改**\n  \n  `git commit -a -m \"<message>\"`:提交所有已修改的文件\n  \n  文件发生变化时，变成**已修改**的状态\n\n​\t\t`git log`：查看历次提交的记录\n\n​\t\tbouns: `git log --pretty=oneline`\n\n可以在vscode里使用图形化界面git\n\n# 常用命令\n\n1. 重置文件\n\n```bash\ngit restore <filename> \n#修改后，还未暂存时，可以用来恢复文件\n\ngit restore --stage <filename> #取消暂存状态，不会取消删除的文件\n```\n\n如果要取回被删的文件，还要再restore一下\n\n\n\n2. 恢复某版本的某文件\n\n   ```bash\n   git checkout 9f955d85359fc8e4504d7220f13fad34f8f2c62b ./recipes/tofu\n   ```\n\n   - 恢复版本`9f955d85359fc8e4504d7220f13fad34f8f2c62b`的文件`./recipes/tofu`\n   - 注意，`checkout`命令不会改变提交记录，且必须==指定要恢复的文件名==，否则会出现bug（如遇此种情况，见：[Git WTFs](https://sp18.datastructur.es/materials/guides/git-wtfs.html)）\n   - 回滚之后，需要再`commit`一次。\n\n   \n\n3. <span id=\"change-commit-messages\">修改最近的提交注释信息</span>：\n\n   ```bash\n   git commit --amend\n   ```\n\n   更多请参考：https://blog.csdn.net/qq_17011423/article/details/104648075\n\n   - 修改前几次的提交注释信息：https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/changing-a-commit-message\n\n   \n\n4. 删除文件\n\n```bash\ngit rm <filename>\ngit rm -f <filename> #强制删除\n\n```\n\n\n\n\n5. 移动文件（重命名）\n\n```bash\ngit mv from to #移动文件/重命名文件\n```\n\n# 分支\n\ngit在commit文件时，每次都会创建一个节点，记录代码的状态。\n\n节点会构成一个树状结构，存在分支。\n\n默认情况下，只有一个分支，叫做 \"master\"\n\n```bash\ngit branch #查看当前分支\ngit branch <branch name> #新建一个分支\ngit branch -D <branch name> #删除分支\ngit switch <branch name>\t#切换分支\ngit switch -c <branch name> #创建并切换分支\n```\n\n在开发中，都是在自己的分支里写代码。写好无误后，再合并分支。\n\n- 合并分支\n\n```bash\ngit switch master\t#切换到主分支\ngit merge <branch name> #合并分支\ngit branch -D <branch name> #合并之后可以删除不需要的分支\n```\n\n\n\n在装了插件的VScode里面的COMMIT DETAILS里，可以通过graph来查看所有分支的情况\n\n<img src=\"..\\img\\gitPics\\image-20221219172950437.png\" alt=\"image-20221219172950437\" style=\"zoom:50%;\" />\n\n有的时候，分支可以快速合并（fast-forward)，但有时候，合并时分支的文件之间会产生冲突。git会帮助你标识出冲突所在，这时候需要手动合并，然后暂存和提交：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>wawawa</h1>\n<<<<<<< HEAD\n    <h2>bugbug fixfix</h2>\n=======\n    <h1>jjj</h1>\n    <h1>wuwuwu</h1>\n    <ul>\n        <li>wiwdiu</li>\n    </ul>\n>>>>>>> test\n</body>\n</html>\n```\n\n# 变基(rebase)\n\n当开发分支较多时，merge会把分支树变得很乱。此时可以使用变基来合并分支。\n\n==注意：==变基操作一般只在自己的本地仓库使用，远程服务器的仓库不可以使用变基。\n\n1. 发起变基时，git会先找到两条最近分支的最近祖先\t\n2. 把当前分支和合并分支的共同祖先进行比对，把所有的变化提取出来存到一个临时文件里\n3. 将当前分支的祖先指向目标分支的基底\n4. 从当前基底开始重新执行之前临时存起来的操作\n\n```bash\ngit switch <filename>\ngit rebase <target filename>\n```\n\n### 利用变基合并commits\n\n参考：\n\n1. https://stackoverflow.com/questions/2563632/how-can-i-merge-two-commits-into-one-if-i-already-started-rebase\n\n2. https://stackoverflow.com/questions/12522565/how-can-i-combine-two-commits-into-one-commit\n\n**注意事项**：如果你正在使用远程仓库，且这个仓库的贡献者不止你一个人，那么在主分支上进行下列操作可能会使他人的文件丢失。您最好==在自己的分支上进行变基==，或者在操作前与他人充分沟通。\n\n**步骤**：\n\n1. 使用`git log --pretty=oneline`查看你需要合并的commits:\n\n```bash\n$ git log --pretty=oneline\na931ac7c808e2471b22b5bd20f0cad046b1c5d0d c\nb76d157d507e819d7511132bdb5a80dd421d854f b\ndf239176e1a2ffac927d8b496ea00d5488481db5 a\n```\n\n假设提交的先后顺序是 a --> b --> c，你需要合并 c 和 b\n\n2. 使用`git rebase -i HEAD~2` （<a href=\"#chatGPT expaination on the command\">chatGPT expaination on the command</a>）,这个命令会打开一个文本文件，让你查看最近的两条提交记录，注意和`git log`输出不同，**较新的提交记录在下面，比较旧的在上面。**\n\n```bash\npick b76d157 b\npick a931ac7 c\n\n# Rebase df23917..a931ac7 onto df23917\n#\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n# However, if you remove everything, the rebase will be aborted.\n#\n```\n\n3. 把**较新的commit**前面的`pick`改成`squash`，然后保存并退出 :\n\n```bash\npick   b76d157 b\nsquash a931ac7 c\n```\n\n4. 之后你会得到提示：\n\n```bash\n# This is a combination of 2 commits.\n# The first commit's message is:\n\nb\n\n# This is the 2nd commit message:\n\nc\n```\n\n5. 再次用`git log --pretty=oneline`查看，就会看到：\n\n```bash\n$ git log --pretty=oneline\n18fd73d3ce748f2a58d1b566c03dd9dafe0b6b4f b and c\ndf239176e1a2ffac927d8b496ea00d5488481db5 a\n```\n\n大功告成！\n\n如果你对commit信息不满意，那么可以自行<a href=\"#change-commit-messages\">修改commit信息</a>。\n\n6. 如果你在推送到远程仓库时失败了，尝试使用`git push -f` 来进行推送。**请确保你的这步操作不会影响到正在使用同一仓库的其他人！！！**\n\n\n\n### chatGPT expaination on the command\n\n> The command `git rebase -i HEAD~6` starts an interactive rebase process that allows you to interactively edit the last six commits on the current branch.\n>\n> More specifically, the `-i` flag tells Git to start an interactive rebase, while `HEAD~6` specifies the parent of the current commit. In this case, the parent of the current commit is six commits ago.\n>\n> By running this command, Git will open an interactive file in your default text editor, showing you the last six commits on the branch. You can then edit the file to choose which commits to keep, squash, or edit, among other options. Once you've made your changes and saved the file, Git will apply your changes and rewrite the Git history of the branch with your new commit history.\n>\n> Note that the `git rebase` command should be used with caution, especially when rewriting Git history. If you're working with a shared repository or collaborating with others, you should communicate with them before rewriting the Git history of a branch.\n\n# tag标签\n\n- 分离头指针：\n\n```bash\ngit switch <commit id> --detach   #commit id可以只写前几位\n```\n\n把头指针移动到早期创建的某个节点上。注意：==此时只能预览，不可以修改和提交代码。==\n\n\n\n- 如果要在早期的节点上进行修改，请在该早期节点上==创建新分支==：\n\n```bash\ngit switch -c <new branch name> <commit id>\n```\n\n\n\n但是，如果版本很多，找到某个特定的节点很困难。使用**标签**来给特定的节点做记号。\n\n- 标签\n\n```bash\ngit tag #显示当前节点的所有标签\ngit tag <tag name> #给当前节点添加一个标签 比如 v1.0\ngit tag <tag name> <cmt id> #给某个节点添加标签\n\n#使用标签来操作：\ngit push <remote> <tag name> #给远程仓库的版本加标签(推送本地标签到远程仓库)\ngit push <remote> --tags #推送所有本地标签\ngit -d <tag name> #删除本地标签\ngit push <remote> --delete <tagname> #删除远程仓库的标签\n```\n\n之后，我们就可以通过标签来快速之前的定位节点，创建新分支了。\n\n```bash\ngit switch -c <tag name>\n```\n\n\n\n# 远程仓库(remote)\n\n- GitHub\n- Gitee\n\n上传到github：\n\n```bash\ngit remote add origin https://github.com/lilichao/git-demo.git\n# git remote add <remote name> <url>\n\ngit branch -M main\n# 修改分支的名字的为main\n\ngit push -u origin main\n# git push 将代码上传服务器上\n```\n\n\n\n## 远程库的操作的命令\n\n```bash\ngit remote # 列出当前的关联的远程库\ngit remote add <远程库名> <url> # 关联远程仓库\ngit remote remove <远程库名>  # 删除远程库\n\ngit push -u <远程库名> <分支名> # 向远程库推送代码，并和当前分支关联\ngit push <远程库> <本地分支>:<远程分支> #推送到指定的远程分支\n\ngit clone <url> # 从远程库下载代码\ngit clone <url> <new filename># 从远程库下载代码,并重命名\n\ngit push # 如果本地的版本低于远程库，push默认是推不上去\ngit fetch # 要想推送成功，必须先确保本地库和远程库的版本一致，fetch它会从远程仓库下载所有代码，但是它不会将代码和当前分支自动合并\n\t\t # 使用fetch拉取代码后，必须要手动对代码进行合并\ngit merge origin/master #手动合并\ngit pull  # 从服务器上拉取代码并自动合并 \n```\n\n==注意：==\n\n==1. 推送代码之前，一定要先从远程库中拉取最新的代码==\n\n==2. 写自己的代码前，一定要创建新分支==\n\n\n\n## origin/main/master\n\n来源：https://blog.csdn.net/reykou/article/details/104866348\n\n1. GIT 初始化：本地默认分支叫 master、服务器默认名为 origin。本地分支 master 同步到服务器上、服务器节点变成 orgin/master\n2. 本地创建分支名为 branch，本地分支 branch 同步到服务器上、服务器节点变成 orgin/branch\n3. 更新本地分支 master，用本地分支 master 更新服务器节点 orgin/master\n\n\n\n## git代理的设置\n\n远程库连接很缓慢，那么，我们可以通过配置代理来解决这个问题。\n\n首先查看你的代理软件的相关设置，搞清楚你代理使用的本地socks端口：\n\n<img src=\"..\\img\\gitPics\\socksPort.png\" style=\"zoom:100%;\" />\n\n```bash\ngit config --global https.proxy http://127.0.0.1:10808  #设置为你自己的端口，比如我的是10808\n\ngit config --global https.proxy https://127.0.0.1:10808\n\ngit config --global --unset http.proxy\n\ngit config --global --unset https.proxy\n```\n\n参考：https://gist.github.com/laispace/666dd7b27e9116faece6\n\n\n\n## 远程库解决push授权问题\n\n配置完代理，可能会引发如下问题：\n\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b/AceMyFile (master)\n$ git push origin master\nfatal: NotSupportedException encountered.\n   The ServicePointManager does not support proxies with the socks5h scheme.\nerror: unable to read askpass response from 'E:/git/Git/mingw64/libexec/git-core/git-gui--askpass'\nUsername for 'https://github.com': xxxx\nremote: Support for password authentication was removed on August 13, 2021.\nremote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.\nfatal: Authentication failed for 'https://github.com/xxxx/xxxx.git/'\n\n```\n\n如果用VSCode推送好像可以绕开这个问题。\n\n但是，如果使用命令行来推送：\n\n```bash\n$ git push origin master\nfatal: NotSupportedException encountered.\n   The ServicePointManager does not support proxies with the socks5h scheme.\nerror: unable to read askpass response from 'E:/apps/git/Git/mingw64/libexec/git-core/git-gui--askpass'\nremote: Support for password authentication was removed on August 13, 2021.\nremote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.\nfatal: Authentication failed for 'https://github.com/0xtopus/CS61B-repo.git/'\n```\n\n发现2021年8月13日之后URL推送的方法就已经不支持了。\n\n于是，我们可以采用ssh的方法来推送。\n\n### ssh方法\n\n参考1：https://www.cnblogs.com/yuqiliu/p/12551258.html\n\n参考2：https://blog.csdn.net/lonyw/article/details/75392410\n\n\n\n1. 先查看自己本地设置的邮箱：\n\n   ```bash\n   git config –global user.email\n   ```\n\n2. 然后输入：\n\n   ```bash\n   ssh-keygen -t rsa -C \"你设置的邮箱\"\n   ```\n\n   代码参数含义：\n\n   -t 指定密钥类型，默认是 rsa ，可以省略。\n   -C 设置注释文字，比如邮箱。\n   -f 指定密钥文件存储文件名。\n\n   然后会输出一些提示让你操作。连续按三个回车，全部默认即可。\n\n   （三个操作分别是：选择使用默认路径存放ssh秘钥（`/c/Users/Administrator/.ssh/id_rsa`），不使用`paaphrase`私钥，确认私钥。\n\n   关于私钥的作用，一般可以不要：\n\n   > What is passphrase in git?\n   >\n   > With SSH keys, if someone gains access to your computer, the attacker can gain access to every system that uses that key. **To add an extra layer of security, you can add a passphrase to your SSH key**. To avoid entering the passphrase every time you connect, you can securely save your passphrase in the SSH agent. \n   >\n   > source: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/working-with-ssh-key-passphrases\n\n   完成以上操作，你会看到类似下面的输出：\n\n   ```bash\n   Generating public/private rsa key pair.\n   Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):\n   Created directory '/c/Users/Administrator/.ssh'.\n   Enter passphrase (empty for no passphrase):\n   Enter same passphrase again:\n   Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa\n   Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub\n   The key fingerprint is:\n   SHA256:lhiwE3T6NRzcttxFPBj5LDpy0CtmnYG/55NqOuRK3Tk gsy@gsy123mailbox.com\n   The key's randomart image is:\n   +---[RSA 3072]----+\n   |   .+ ....  .*.  |\n   |     * ...o o +  |\n   |    + . += o + . |\n   |     o +oo= o o  |\n   |      o S+ = .   |\n   |       o*.O.     |\n   |      .=.+Eo .   |\n   |     .  o o.+    |\n   |      ...+.+..   |\n   +----[SHA256]-----+\n   \n   ```\n\n3. 然后输入：\n\n   ```bash\n   ssh -T git@github.com\n   ```\n\n   得到输出：\n\n   ```bash\n   The authenticity of host 'github.com (140.82.112.4)' can't be established.\n   ECDSA key fingerprint is SHA256:xxxxxx.\n   Are you sure you want to continue connecting (yes/no/[fingerprint])? \n   ```\n\n   输入yes，回车继续，看到如下输出即成功：\n\n   ```bash\n   Warning: Permanently added 'github.com,140.82.112.4' (ECDSA) to the list of known hosts.\n   Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access.\n   ```\n\n   \n\n4. 接下来可以通过`git remote -v`查看远程主机的状态，看到：\n\n   ```bash\n   origin  https://github.com/xxxx.git (fetch)\n   origin  https://github.com/xxxx.git (push)\n   ```\n\n   说明还是通过URL方式访问，接下来我们来修改为ssh方式。\n\n5. 打开你的github仓库页面：\n\n   <img src=\"..\\img\\gitPics\\ssh.png\" style=\"zoom:75%;\" />\n\n6.  输入下列命令：\n\n   ```bash\n   git remote set-url origin git@github.com:xxxx.git\n   ```\n\n   `git@github.com:xxxx.git`就是你刚刚复制的内容。\n\n   再次`git remote -v`\n\n   看到：\n\n   ```bash\n   origin  git@github.com:xxxx.git (fetch)\n   origin  git@github.com:xxxx.git (push)\n   ```\n\n   就大功告成啦！\n\n   现在就可以直接push了：\n\n   ```bash\n    git push origin master\n   ```\n\n   \n\n\n\n\n\n\n\n## GitHub添加/删除关联的远程仓库\n\n参考：https://blog.csdn.net/ltstud/article/details/79935001\n\n```bash\ngit remote add <远程仓库名> <本地库名>\ngit remote rm <远程仓库名> \n```\n\n\n\n# 换邮箱后的配置\n\n比如ssh什么的，参见：https://gist.github.com/Heron-Wang/1f608c4c93065d1ebd67f7b29e3be791\n\n\n\n# gitignore\n\n- 默认情况下，git会监视项目里所有的文件。但是有时候，不是所有的文件都需要被git监视。\n- 使用 *gitignore* 来让git忽略它们\n- 在项目目录里新建一个 `.gitignore` 文件，把要忽略的文件名输入进去\n\n```\n#注释\nnode_modules\nyarn.lock\n*.log\n```\n\n\n\n## git ignore 配置\n\n1. 使用`!<filename>`来使git不忽略某个文件。比如你需要git不忽略某个叫做`MyFile`的文件夹下的所有文件，在`.gitignore`里你可以这样写：\n\n   ```txt\n   !MyFile/*\n   ```\n\n   \n\n2. \n\n\n\n# 查看git配置\n\n```bash\ngit config <配置名> #查看某个配置情况\n```\n\n更多配置：https://www.atlassian.com/zh/git/tutorials/setting-up-a-repository/git-config\n\n\n\n# GitHub 只添加已追踪的文件\n\n```bash\ngit add -u\n```\n\nref: https://www.google.com/search?q=how+to+add+tracked+files+only+in+git&oq=how+to+add+tracked+files+only+in&aqs=chrome.1.69i57j33i10i160l3.16226j0j9&sourceid=chrome&ie=UTF-8\n\n使用前：\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   lab2/DebugPractice/DebugExercise1.java\n        modified:   lab2/DebugPractice/DebugExercise2.java\n        modified:   lab2/Intlist/IntList.java\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        lab2/.idea/\n        lab2setup/.idea/\n        lab2setup/out/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n使用：\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git add -u\n```\n\n使用后：\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        modified:   lab2/DebugPractice/DebugExercise1.java\n        modified:   lab2/DebugPractice/DebugExercise2.java\n        modified:   lab2/Intlist/IntList.java\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        lab2/.idea/\n        lab2setup/.idea/\n        lab2setup/out/\n\n```\n\n\n\n# Github ICU\n\n远程仓库和本地仓库出现较大混乱时，可以这样恢复到希望回到的之前的某个commit版本。\n\n首先，进入你的本地仓库，使用`git log`命令找到你希望退回的**commit版本号**，然后使用：\n\n```bash\ngit reset --hard <commit>\n```\n\n回到你希望的commit版本。但是，在使用之前，==你最好将文件进行备份==，以免reset到错误的版本后丢失数据。\n\n你也可以使用`git reflog`来查看之前的操作，并且可以通过`git reflog`里提供的commit版本号来再次使用`reset --hard`命令回溯到操作前所在的commit版本（可以作为reset错误后的后悔药！）\n\n然后，对远程仓库使用强行同步更新：\n\n```bash\ngit push -f \n```\n\n[^参考1]:  https://stackoverflow.com/questions/42860234/how-to-undo-a-merge-in-github，Stack Overflow的相关回答。\n[^参考2]:  https://initialcommit.com/blog/git-reset，对reset的详细讲解\n[^参考3]:https://stackoverflow.com/questions/495345/how-to-remove-selected-commit-log-entries-from-a-git-repository-while-keeping-th，Stack Overflow.\n[^参考4]: https://stackoverflow.com/questions/4114095/how-do-i-revert-a-git-repository-to-a-previous-commit，Stack Overflow上的一个比较详细的高赞回答，不过我没细看...\n[^参考5]: https://stackoverflow.com/questions/29042783/how-can-i-delete-all-commits-before-a-given-date-in-git-history，Stack Overflow：how can I delete all commits before a given date in git history.\n\n\n\n```bash\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git log\ncommit cca2edf5fbf99d5295cca7c0c56c807f0e2194ab (HEAD -> master, origin/master, origin/HEAD)\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 11 17:00:26 2023 +0800\n\n    reset files\n\ncommit ad9c8610ec1d326fa88c7a8088ae53b4fe6fff5c\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Fri Feb 10 11:06:37 2023 +0800\n\n    fix the bug of IntList.java*\n\ncommit c0ae005a84005d9f528673b36ca4507386ac711c\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Thu Feb 9 23:02:06 2023 +0800\n\n    add IntList.java with a small bug which would count one less size of the IntList and also modify my note a bit\n\ncommit 3bae4aa49e997c62db531f53c6427ea510f90942\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Wed Feb 8 22:26:27 2023 +0800\n\n    add .gitignore, SumArg.java and modify my note\n\ncommit 4f461e2ca33d4d7e878011305dd401d91209f13e\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 4 23:26:25 2023 +0800\n\n    create new README file and tweak my first week  java note\n\ncommit 14f93eae87f460eebf10617cbb650d2ca0af8c57\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 4 23:20:55 2023 +0800\n\n    finish the first week task\n\ncommit 5551fe36d65a915e35b7af01beb615cf596d9902\nAuthor: cyber_octopus <gsy@gsy123mailbox.com>\nDate:   Sat Feb 4 21:47:51 2023 +0800\n\n    commit first week's stuff\n\n\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git reflog\ncca2edf (HEAD -> master, origin/master, origin/HEAD) HEAD@{0}: commit: reset files\nad9c861 HEAD@{1}: reset: moving to ad9c8610\na09fb44 HEAD@{2}: checkout: moving from master to master\na09fb44 HEAD@{3}: pull --allow-unrelated-histories: Merge made by the 'recursive' strategy.\n7ef79fc HEAD@{4}: rebase finished: returning to refs/heads/master\n7ef79fc HEAD@{5}: rebase: delete all skeleton files\n4f0a62f HEAD@{6}: rebase: delete all skeleton file and try to set up again\n0515c34 HEAD@{7}: rebase: lab1 ready to submit\na3610f2 HEAD@{8}: rebase: add all files from official repo of cs61b\nad9c861 HEAD@{9}: rebase: fix the bug of IntList.java*\nc0ae005 HEAD@{10}: rebase: add IntList.java with a small bug which would count one less size of the IntList and also modify my note a bit\n3bae4aa HEAD@{11}: rebase: add .gitignore, SumArg.java and modify my note\n4f461e2 HEAD@{12}: pull --rebase --allow-unrelated-histories skeleton master: create new README file and tweak my first week java note\n14f93ea HEAD@{13}: pull --rebase --allow-unrelated-histories skeleton master: finish the first week task\n5551fe3 HEAD@{14}: pull --rebase --allow-unrelated-histories skeleton master: commit first week's stuff\nfa6b0b8 (skeleton/master) HEAD@{15}: pull --rebase --allow-unrelated-histories skeleton master: checkout fa6b0b8a7f1d83bf1aa47b9182bce4cad238f14e\n\nAdministrator@USER-20160428EL MINGW64 /f/awsl/Java/cs61b (master)\n$ git reset 7ef79fc\n\n```\n\n\n\n\n\n\n\n# GitHub大量删除和添加文档后批量暂存\n\n参考：https://blog.csdn.net/haohaibo031113/article/details/70821321\n\n```bash\ngit add -A  # GitHub大量删除和添加文档后批量暂存，也可以用 rm 命令来处理删除的文件\n```\n\n\n\n# GitHub重命名远程仓库\n\n```bash\ngit branch -M main #把当前master分支改名为main, 其中-M的意思是移动或者重命名当前分支\n```\n\n参考：https://juejin.cn/post/7051873701305778207\n\n\n\n# 小技巧\n\n1. 在命令行模式下，在要打开的目录里输入：\n\n```bash\ncode .\n```\n\n即可用vscode打开当前目录\n\n# 深入研究\n\nhttps://git-scm.com/book/en/v2\n\n# GitHub部署静态页面\n\n详见Hexo，Docusaurus等静态站点生成器的官网。\n\n\n\n# 复习\n\n在https://learngitbranching.js.org/?locale=zh_CN上练习git的基本操作命令，将复习的笔记记录在这里。\n\n## 分支\n\n```bash\ngit branch <new branch name>\n```\n\n- Switch to the new branch:\n\n```bash\ngit checkout <branch name>\n# or you can use:\ngit switch <branch name>\n```\n\n- Create new branch and switch to it immediately:\n\n```bash\ngit checkout -b <new branch name>\n```\n\n## Merge\n\n- To merge branches, say if there are two parallel branches `bugFix` and `main`, and we want to merge `bugFix` to `main`:\n\n```bash\ngit switch main\t# switch to the target branch\ngit merge bugFix # merge another branch to the target branch\n```\n\n## Rebase\n\nTo make commit history look more linear, we can \"rebase\" one of two parallel branches to another:\n\n```bash\ngit switch bugFix\ngit rebase main\n# now your \"bugFix\" branch is one node ahead of \"main\" branch\n```\n\n## HEAD Moving\n\nBy default, HEAD always points to the latest commit history. It is like: `HEAD -> main -> \"Hashtag of last commit\"`.\n\nTo move \"HEAD\" to point to a commit history at somewhere:\n\n```bash\ngit checkout <Hashtag of the commit history>\n```\n\nnow the HEAD is pointing to the given hashtag: `HEAD -> the given hashtag`\n\n- Relative branch movement:\n\n```bash\ngit branch -f <branch to move> <reference name>~<num>\n# for example:\ngit branch -f main HEAD~\t\t# move main to the previous node of HEAD\ngit branch -f bugFix <Hashtag>\t# move bugFix to the specified hashtag\ngit branch -f main bugFix~2 \t# move main to the second previous node of bugFix\n```\n\n- Atn alternative way to move HEAD\n\n```bash\n# All these three move HEAD according to the relative position of target\ngit checkout main^\ngit checkout <hashtag>^\ngit checkout HEAD~\n```\n\n## Undo changes\n\n- `git revert`: create a new commit which is identical to the given one.\n\n  <span style=\"font-weight:bold;color:red\">Recommend when there's something need to be undone in remote repo</span>\n\n```bash\ngit revert HEAD\t# create a new commit the same as the previous one to the current commit.\n```\n\n- `git reset`: move the commit backward(The change of undone commit is still alive but in the state of not added.) \n\n  <span style=\"font-weight:bold;color:red\">Recommend to edit local commit history only!</span>\n\n```bash\ngit reset HEAD~1\t# undo the latest commit\n```\n\n\n\n"},{"title":"DSP知识整理","url":"/dsp知识整理/","content":"\n\n推荐参考书籍：《手把手教你学DSP—基于TMS320X281x》（第3版） *顾卫钢*\n\n# 一、DSP概述\n\n### 硬件：\n\n- 高速控制和信号处理\n- 采用流水线操作\n- 采用哈佛结构，数据存储区和程序存储区分离，数据总线和程序总线也是分开的\n- 大多配有硬件乘法器和加法器，同一时钟周期内可以完成累加和累乘\n- 零开销循环\n\n### 软件：\n- 显示MAC（乘加器）指令\n- 精简指令集\n- 专门的寻址方式\n\n### DSP分类\n\n按数据格式分：\n- 定点\n- 浮点\n\n按用途分：\n- 通用\n- 专用\n\n### DSP的应用\n1. 数字电机控制\n2. 数字电源供应\n3. 高级传感器\n4. ...\n\n\n# 二、TMS320F2812\n\n### C2000系列DSP\n1. Piccolo系列\n   - F2802x, F2803x/5x, F2806x\n2. Delfino系列\n   - F2833x/23x, C2834x, F2837xS, F2837xD \n\n### CPU\n\n- 32位定点CPU\n- 150MHz\n- 当频率为135MHz时，核心电压1.8V；当频率为150MHz时，核心电压为1.9V；输出IO口电压为3.3V\n\n### 内存\n\n- 18kW RAM\n- 128kW Flash\n\n### 总线\n\n- 3条地址总线\n  - PAB：程序地址总线，**22位**\n  - DRAB：数据读地址总线，32位\n  - DWAB：数据写地址总线，32位\n- 3条数据总线\n  - DRDB：数据读数据总线，32位\n  - DWDB：数据写数据总线，32位\n  - PRDB：程序读数据总线，32位\n\n### 外设功能模块\n- 控制类\n  - IO\n  - 定时器\n  - PWM\n\n- 测量类\n  - 数字：捕获、正交编码\n  - 模拟：ADC\n\n- 通讯类\n  - UART\n  - eCAN\n  - SPI\n  - McBsp\n\n### 其他\n\n外设中断扩展模块（PIE）\n- 支持45个外部中断\n\n片上存储器\n- 128kW Flash，受到CSM（Code Security Module）保护\n- 1kW的OTP型存储器（一次性可编程ROM），受到CSM的保护；\n- 18kW的SARAM\n  - L0和L1：两个4kW的SARAM, 受到CSM的保护\n  - H0: 8kW\n  - M0和M1：两个1kW的SARAM\n- 56个可编程IO口\n- 时钟和系统控制\n- 3个32位CPU定时器\n- 马达控制外设\n  - 两个事件管理器\n- 12位ADC，16通道\n\n### 寻址方式\n\n1. 直接寻址\n2. 间接寻址\n3. 寄存器寻址\n4. 堆栈寻址\n5. 数据/地址/IO空间立即寻址方式\n6. 程序空间间接寻址方式\n\n### C28x流水线\n- 八级流水线，五个阶段\n- 取指令，译码，读取数据，执行，写回\n\n# 三、时钟和系统控制\n![OSC&PLL](../img/DSP/OSC&PLL.png)\n时钟CLKIN的来源有两种，一种是外部晶振提供，另一种是外部时钟输入。可以通过引脚<span style=\"text-decoration: overline\">XF_PLLDIS</span>来控制选择。\n\n- 晶振：20MHz ~ 35MHz\n- 外部时钟：有PLL: 5 ~ 100MHz；无PLL: 4 ~ 150MHz\n\n在使用对应的外设之前，需要使能它们的时钟。与外设时钟使能相关的寄存器是<u>外设时钟使能寄存器PCLKCR</u>。\n\nSYSCLK经过分频可以得到低速外设时钟LSPCLK和高速外设时钟HSPCLK，它们互相独立，分别给高速外设和低速外设供应时钟信号。\n\n<img src=\"..\\img\\DSP\\HSPCLK_LSPCLK.png\" style=\"zoom:75%;\" />\n\n\n\n### 看门狗电路\n\n当八位的<u>看门狗加法计数器WDCNTR</u>达到最大值时，看门狗模块输出一个512个周期的脉冲，使系统复位。\n\n如果不想使用看门狗，可以直接禁止看门狗。\n\n如果启用了看门狗，当程序正常运行时，我们需要定期向WDCNTR依次顺序写入0x55和0xAA来清零，实现“喂狗”操作。\n\n逻辑校验位是看门狗的另一个安全机制，访问<u>看门狗控制器WDCR</u>的写操作中，相应的校验位必须为“101”，否则会立即拒绝访问并引发系统复位。\n\n### 低功耗模式\n\n- 空闲模式：CPU进入低功耗模式，部分外设不使用时时钟选择性关闭，会自动降低频率来降低功耗，任何使能的外设中断都可以唤醒此模式。\n- 暂停模式：片上所有设备停止工作\n- 备用模式：关闭CPU和外设时钟，OSC和PLL正常工作\n\n# 四、CPU定时器\n\nx2812内部有3个32位的CPU定时器，其中只有Timer0可供用户使用，Timer1和Timer2都被系统保留。\n\n欲使用CPU定时器来计时，需要设置两个寄存器：\n\n- 周期寄存器 PRDH:PRD\n- 分频器寄存器 TDDRH:TDDR\n\n计数器的周期有以下两个公式：\n\n${TIMCLK = \\frac{TDDRH:TDDR + 1 }{SYSCLK} * 10^{-6}}$\n\n${Period = (PRDH:PRD + 1) * TIMCLK}$\n\n# 五、编程\n\n## 程序文件\n\n- 源程序文件：C，汇编文件\n- 头文件：.h文件\n- 命令文件(cmd)：对程序和数据存储空间进行分配\n- 运行支持库\n\n## 命令文件\n\n伪指令：\n\n- MEMORY：用来指示存储空间\n  - PAGE0：程序空间\n  - PAGE1：数据空间\n- SECTION：用来分配到储存空间\n  - 段：\n    - .cinit：存放用来对全局 和静态变量初始化的函数\n    - .text：存放编译C语言时产生的汇编代码\n    - .econst：包含字符串常量、全局变量和静态变量的初始化和说明\n    - .ebss：使用大寄存器模式时为全局变量和静态变量所预留的空间\n    - .stack：为系统堆栈保留的空间，主要用于函数传递变量和为局部变量分配空间。\n\n# 六、GPIO\n\n总共56个可编程复用IO口，分为ABDEFG六组。复位默认为输入口。可提供4mA输入电流。\n\n寄存器：\n\n- GPxMUX\n  - 写0，设置为数字IO口\n  - 写1，功能复用\n- GPxDIR\n  - 写0，输入\n  - 写1，输出\n- GPxDAT\n  - 写0，拉低输出\n  - 写1，拉高输出\n  - 存在一定的问题，建议使用下面三个寄存器来操作\n- GPxSet：只能写1\n- GPxClear：只能写1\n- GPxTOGGLE：只能写1\n\n```c\n// 置位输出\nGpioDataReg.GPASET.bit.GPIOA0 = 1;\n// 读取输入\nif(GpioDataReg.GPASET.bit.GPIOA2 == 0) {\n    ...\n}\n```\n\n \n\n# 七、中断\n\n中断的类型：\n\n- 触发形式\n  - 软件中断\n  - 硬件中断\n    - 内部中断\n    - 外部中断\n- 能否屏蔽\n  - 可屏蔽中断\n  - 不可屏蔽中断\n\n## 中断优先级\n\n在不同组内INT1最大，在PIE同组内，INTx.1最大。\n\n## CPU级中断\n\nCPU中的中断由IER和INTM控制。IER控制每个可屏蔽中断，INTM相当于总闸。\n\n## PIE中断\n\n外设中断扩展模块（PIE），对各种中断请求源进行处理。\n\nPIE一共支持96个中断，这些中断被分为了12个组，每组由8个中断。每个组都被反馈到 <span style=\"text-decoration:overline\" >INT1</span> ~ <span style=\"text-decoration:overline\" >INT12</span> 这12条中断线上的某一条。\n\n## PIE中断向量表\n\nDSP中各个中断服务子程序的地址储存在一片连续的RAM（大小为256x16）内，这就是中断向量表。\n\n## 2812的三级中断系统\n\n三级系统都要允许，某中断才会发生。\n\n- 外设级\n\n  - 当外设中断标志位被置1，且该外设中断为使能状态，此时外设向PIE发出中断请求；\n  - <span style=\"color:red; font-weight:bold\">外设中断标志位置位后必须<u>手动清除</u>！！！</span>\n\n  ```c\n  CpuTimer0Reg.TCR.bit.TIF = 1;\t// 写1来手动清除外设寄存器中的标志位\n  ```\n\n  \n\n- PIE级\n\n  - 除了中断标志寄存器和中断使能寄存器，还有中断应答寄存器。\n  - 同组内的中断在响应时，如果发生了其他同组中断，若中断应答寄存器没有被手动清零，后发生的中断不会被响应。<span style=\"color:red; font-weight:bold\">中断应答寄存器需要手动清除</span>。PIE级中断的标志位不需要手动清除。\n\n  ```c\n  PieCtrl.PIEACK.bit.ACK1 = 1;\n  ```\n\n  \n\n- CPU级\n\n  - 当外设中断请求发送到CPU时，CPU的中断标志寄存器IFR对应位置位。这时，CPU检查IER对应的位是否置位，以及INTM是否<span style=\"color:red; font-weight:bold\">为0</span>。\n\n<img src=\"..\\img\\DSP\\INTERRUPTION.png\" style=\"zoom:75%;\" />\n\n## 中断函数的编写\n\n1. 使能某个中断：\n\n```c\nvoid InitXXX(void) {\n    ...\n    CpuTimer0Regs.TCR.bit.TIE = 1;\t// 使能定时器0的周期中断\n    ...\n}\n```\n\n2. 在主函数里：\n\n```c\nvoid main(void) {\n    InitXXX();\n    DINT;\n    IER = 0x0000;\n    IFR = 0x0000;\n    InitPieCtrl();\n    InitPieVectTable():\n    // 使能PIE的中断\n    PieCtrl.PIEIER1.bit.INTx7 = 1;\n    IER |= M_INT1;\n    EINT;\n}\n```\n\n3. 在DSP28_DefaultIsr.c文件里配置中断函数\n\n```c\ninterrupt void TINT0_ISR(void) {\n    ...\n    CpuTimer0Regs.TCR.bit.TIF = 1;\n    PieCtrl.PIEACK.bit.ACK1 = 1;\n    EINT;\n}\n```\n\n\n\n# 八、EV模块（事件管理器）\n\n两个事件管理器Eva和Evb，两个事件管理器的功能是一模一样的。\n\n下面**针对Eva**来介绍事件管理器的结构：\n\n- 2个16位通用定时器，每个定时器可以产生1路独立的PWM波。\n- 3个比较单元\n- 3个捕获单元\n- 1个正交编码脉冲电路\n\nEvb和Eva类似。\n\n## 通用定时器\n\n### 功能\n\n1. 计时\n2. 使用定时器的比较功能产生PWM波\n3. 给Ev的其他模块提供时钟\n\n### 寄存器\n\n**GPTimer1**的寄存器们be like:\n\n- 16位周期寄存器T1PR（带有阴影寄存器）\n- 16位比较寄存器T1CMPR（带有阴影寄存器）\n- 定时器计数器寄存器T1CNT\n- 16位控制寄存器T1CON\n- 16位通用定时器控制寄存器GPTCONA\n\n### 通用定时器的时钟\n\nSYSCLK  --> HSPCLK --> TCLK\n\n$TCLK = \\frac{HSPCLK}{2^{p}}$\n\n其中，p = 1 ~ 128\n\n### 计数方式\n\nGPTimer1通过T1CON的TMODE1和TMODE0控制计数方式。\n\n| TMODE1 | TMODE0 |       描述        |\n| :----: | :----: | :---------------: |\n|   0    |   0    |   停止/保持模式   |\n|   0    |   1    | 连续增/减计数模式 |\n|   1    |   0    |  连续增计数模式   |\n|   1    |   1    | 定向增/减计数模式 |\n\n对定向增/减计数模式的说明：当为定向增/减计数模式时，计时器工作在递增还是递减模式取决于引脚TDIRA的电平，高电平递增，低电平递减。\n\n### 中断事件\n\n- 上溢中断\n- 下溢中断\n- 比较中断\n- 周期中断\n\n### PWM波\n\n要产生PWM波：\n\n- 使能定时器的T1CON的TECMPR位为1（比较使能）\n- GPTCONA的TCMPOE位为1（输出使能）\n\n此时，T1PWM_T1CMP引脚输出PWM波。当T1CNT与T1CMPR的值相匹配时，引脚T1PWM_T1CMP电平就会发生跳变。\n\n产生的PWM波有两种：\n\n- 不对称（连续增计数模式）\n- 对称（连续增\\减计数模式）\n\n可以配置GPTCONA的T1PIN[1:0]位控制输出的极性：\n\n| 位1  | 位0  |    描述    |\n| :--: | :--: | :--------: |\n|  0   |  0   |   强制低   |\n|  0   |  1   | 低电平有效 |\n|  1   |  0   | 高电平有效 |\n|  1   |  1   |   强制高   |\n\n低电平有效就是T1CNT的值比T1CMPR小的时候输出高电平，其他以此类推。\n\n定时器的周期为：\n\n非对称模式：\n\n$T = (T1PR + 1) * TCLK$\n\n对称模式：\n\n$T = (2 * T1PR) *TCLK$\n\n## 全比较单元\n\nEva、Evb各有3个全比较单元（加起来总共6个），每个比较单元都可以输出2路互补的PWM波，所以Eva或者Evb可以都有能力驱动一个三相全桥电路。（当然你也可以设置输出的两路PWM完全相同）\n\n### 寄存器\n\n按Eva和Evb来分：\n\n- 16位比较寄存器CMPR1~3， CMPR4~6，共6个（都有阴影寄存器）\n- 16位比较控制寄存器COMCONA和COMCONB，共2个\n- 16位行为控制寄存器ACTRA和ACTRB（都有阴影寄存器）\n\n以Eva为例，输出的PWM极性可以通过ACTRA的位CMP1和CMP2控制。使能COMCONA的CENABLE和FCMPOE位时即可产生两路互补的PWM波。\n\n每个比较寄存器都有两个对应的PWM输出引脚：比如CMPR1对应PWM1和PWM2\n\n输出的PWM波类型和GPTimer是一样的。只是把T1CMPR改成CMPRx即可。\n\n带有死区控制的PWM不考，不写了。\n\n## 捕获单元\n\n捕获单元能够捕获外部输入引脚CAPx_QEPx的电平变化。当捕获到指定的电平变化时，捕获单元就记录下定时器的时间。利用两次捕获的时间差，捕获单元就可以测量出信号的脉宽。\n\n2812的Eva和Evb各有三个捕获单元CAP1 ~ 3和CAP4 ~ 6。每个捕获单元都有一个捕获输入\n\n引脚，通过配置相关寄存器可以捕获输入波形的上升沿、下降沿或者同时捕获上升沿和下降沿。当引脚检测到指定的变化时，所选用的定时器的值将被捕获并锁存到对应的2级FIFO堆栈中。注意，从引脚发生变化到锁存定时器的值需要至少2个时钟周期，所以**输入信号至少要保持2个时钟周期**。\n\n### 寄存器\n\n- 捕获控制寄存器CAPCONA, CAPCONB\n- 捕获FIFO状态寄存器CAPFIFOA， CAPFIFOB\n- 两级深度的FIFO堆栈CAPFIFOx, CAPFBOTx (x = 1 ~ 6)\n\n以Eva的CAP1为例，在堆栈为空的时候，捕获状态寄存器CAPFIFOA的CAP1FIFO状态位为00，发生一次捕获后，定时器计数寄存器T1CNT的值被存入栈顶，CAP1FIFO状态位为01，第二次捕获后，数据存入栈底，堆栈全满，CAP1FIFO状态位变为10；第三次捕获后，栈顶的数据出栈，第二次捕获的来到栈顶，第三次捕获的来到栈底。如果没有读取第一次捕获的值（第一次捕获的值丢失），则CAP1FIFO状态位变为11；否则如果在第三次捕获前已经读取了第一次捕获的值，则CAP1FIFO状态位仍为10.\n\n\n\n### 中断\n\n以Eva为例，捕获单元1具有捕获中断CAP1INT，捕获单元2有CAP2INT，捕获单元3有CAP3INT...\n\n中断发生的条件：\n\n1. 捕获单元捕获到信号发生指定的变化\n2. 此时CAPxFIFO不为0（堆栈非空）\n\n则此时中断标志位被置位。\n\n和中断相关的寄存器：\n\n- 中断标志寄存器EVAIFRC，EVBIFRC\n- 中断屏蔽寄存器EVAIMRC和EVBIMRC（用来使能中断的）\n\n## 正交编码电路\n\n每个事件管理器都有一个正交编码电路（QEP电路），光电码盘输出的两路正交编码信号从两个输入引脚输入到QEP电路，在通过两个QEP电路的译码器对正交编码信号进行译码，最后就能得到电机转子的转速、旋转方向、旋转位置等信息。\n\n\n\n```c\n/*\n * 自己写的事件管理器Init函数\n * 配置了全比较单元输出PWM波和捕获单元捕获上升下降沿\n */\nvoid InitEv(void)\n{\n\t/*\n\t * 配置GP Timer2\n\t */\n\tEvaRegs.T2CON.bit.TENABLE = 0; \t// 暂时禁止t2计数\n\tEvaRegs.T2CON.bit.TPS = 0;\t\t\t// 输入计数时钟为HSPCLK = 75MHz\n\tEvaRegs.T2CON.bit.TMODE = 2; \t\t// GP Timer2连续增计数模式\n\tEvaRegs.T2CON.bit.TCLKS10 = 0; \t// 选择内部时钟T2CLK\n\n\tEvaRegs.T2CNT = 0x0000;\t// Clear the counter for GP timer 2\n\tEvaRegs.T2PR = 0x3A97;\t\t// 频率为5kHz，PR = 14999\n\n\t/*\n\t * GP Timer2周期中断配置\n\t*/\n\tEvaRegs.EVAIMRB.bit.T2PINT = 1;\t\t// 使能GP Timer2周期中断\n\tEvaRegs.EVAIFRB.bit.T2PINT = 1;\t\t\t// 复位GP Timer2周期中断标志位\n\n\n\t/*\n\t * 配置GP Timer1\n\t */\n\tEvaRegs.T1CON.bit.TENABLE = 0; \t// 暂时禁止t1计数\n\tEvaRegs.T1CON.bit.TPS = 0;\t\t\t// 输入计数时钟为HSPCLK = 75MHz\n\tEvaRegs.T1CON.bit.TMODE = 2; \t\t// GP Timer1连续增计数模式\n\tEvaRegs.T1CON.bit.TCLKS10 = 0; \t// 选择内部时钟T1CLK\n\n\tEvaRegs.T1CNT = 0x0000;\t\t// Clear the counter for GP timer 1\n\tEvaRegs.T1PR = 0x3A97;\t\t// 频率为5kHz，PR = 14999\n\n\t/*\n\t * 配置全比较模块\n\t */\n\tEvaRegs.COMCONA.bit.CENABLE = 1;\t\t// 使能EVA的全比较操作\n\tEvaRegs.COMCONA.bit.FCOMPOE = 1;\t// 使能比较输出\n\n\tEvaRegs.COMCONA.bit.CLD = 0;\t\t\t\t// 比较寄存器重载条件为下溢中断\n\n\tEvaRegs.CMPR1 = 0x1D4C;\t// 默认占空比为50%\n\tEvaRegs.CMPR2 = 0x1D4C;\t// 默认占空比为50%\n\tEvaRegs.CMPR3 = 0x1D4C;\t// 默认占空比为50%\n\tEvaRegs.ACTR.all = 0;\t\t\t// 全部强制低\n\n\t/*\n\t * GP Timer1下溢中断配置\n\t */\n\tEvaRegs.EVAIMRA.bit.T1UFINT = 1;\t\t// 使能GP Timer1下溢中断\n\tEvaRegs.EVAIFRA.bit.T1UFINT = 1;\t\t// 复位GP Timer1下溢中断标志位\n    \n    \n    EvaRegs.CAPFIFO.all = 0; // 初始化CAPFIFOA\n\n\tEvaRegs.CAPCON.bit.CAPRES = 0; \t\t\t// 清零捕获寄存器\n\tEvaRegs.CAPCON.bit.CAPQEPN = 1; \t\t// 使能捕获单元1,2\n\tEvaRegs.CAPCON.bit.CAP3EN = 1;\t\t\t// 使能捕获单元3\n\tEvaRegs.CAPCON.bit.CAP3TSEL = 1;\t\t// 捕获单元3时基为timer1\n\tEvaRegs.CAPCON.bit.CAP12TSEL = 1;\t\t// 捕获单元1,2时基为timer1\n\n\tEvaRegs.CAPCON.bit.CAP1EDGE = 0x3;\t// 捕获单元1捕获边沿为上升下降沿\n\tEvaRegs.CAPCON.bit.CAP2EDGE = 0x3;\t// 捕获单元2捕获边沿为上升下降沿\n\tEvaRegs.CAPCON.bit.CAP3EDGE = 0x3;\t// 捕获单元3捕获边沿为上升下降沿\n\n\tEvaRegs.EVAIMRC.bit.CAP1INT = 1;\t\t// 使能捕获单元1中断\n\tEvaRegs.EVAIMRC.bit.CAP2INT = 1;\t\t// 使能捕获单元2中断\n\tEvaRegs.EVAIMRC.bit.CAP3INT = 1;\t\t// 使能捕获单元3中断\n\tEvaRegs.EVAIFRC.all = 0x7;\t\t// 复位捕获单元中断标志位\n\n\tEvaRegs.T1CON.bit.TENABLE = 1; \t// 使能t1计数\n\n}\n```\n\n\n\n# 九、ADC\n\n- 2812的ADC分辨率为12bit，具有流水线结构，具有16个通道，分为2组：一组为ADCINA0 ~ ADCINA7，另一组为ADCINB0 ~ ADCINB7，分别对应两个采样保持器。虽然通道很多，但是转换器只有一个，所以要对各通道进行排序转换。\n\n- ADC模块的时钟最高频率为25MHz，最高采样率为12.5MSPS（sample per second）。\n- ADC电压的采样范围是<u>0 ~ 3 V</u>\n- ADC模块对一个序列的通道开始转换必须要有一个启动信号来触发，当信号到来时，相应的序列发生器就开始对内部预先指定的通道进行转换。\n- ADC有两种工作模式：\n  - 两个独立的8通道\n  - 级联16个通道\n- ADC共有16个结果寄存器来存储转换的数值。\n\n## 工作方式\n\n通过16位的ADC输入通道选择序列控制寄存器ADCCHSELSEQx（x=1, 2, 3, 4）可以控制ADC通道的<u>转换顺序</u>。\n\n每个ADCCHSELSEQx被分为了4段，每段其名为：CONVxx（x = 00 ~ 15）。\n\n- 当ADC工作在**双序列发生器模式**下时，序列发生器SEQ1使用ADCCHSELSEQ1和2，每个CONVx可以选择的通道为ADCINA0 ~ 7；SEQ2使用ADCCHSELSEQ3和4，每个CONVx可以选择的通道为ADCINB0 ~ 7;\n- 当ADC工作在**级联模式**下时则都可自由选择。\n\nADC转换的<u>通道数量</u>由最大通道转换寄存器ADCMAXCONV决定。\n\n- 当工作在双序列发生器模式下时，该寄存器的低三位[0:2]所代表的**二进制数 + 1**决定SEQ1序列发生器转换的通道数量；[4:6]位决定SEQ2转换的通道数量。\n- 工作在级联模式下时，低四位[0:3]决定转换通道的数量，为其代表的**二进制数 + 1**\n\nADC还有顺序采样和并发采样两种采样方式，所以排列组合一下，就有：\n\n- 双通道顺序采样\n- 级联顺序采样\n- 双通道并发采样\n- 级联并发采样\n\n四种模式。\n\n下面是一个配置双序列顺序采样的例子：\n\n```c\n\tAdcRegs.ADCTRL1.bit.SEQ_CASC = 0; //独立双排序模式\n\tAdcRegs.ADCTRL1.bit.CONT_RUN = 0; //启动停止模式\n\n\t// 级联双排序的排序器配置\n\tAdcRegs.MAX_CONV.bit.MAX_CONV = 0x0032; // B组采样通道为4，A组采样通道为3\n\tAdcRegs.CHSELSEQ1.bit.CONV00 = 0x0; // 选择模拟通道ADCINA0\n\tAdcRegs.CHSELSEQ1.bit.CONV01 = 0x1; // 选择模拟通道ADCINA1\n\tAdcRegs.CHSELSEQ1.bit.CONV02 = 0x2; // 选择模拟通道ADCINA2\n\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xB; // 选择模拟通道ADCINB3\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xC; // 选择模拟通道ADCINB4\t\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xD; // 选择模拟通道ADCINB5\n\tAdcRegs.CHSELSEQ3.bit.CONV08 = 0xE; // 选择模拟通道ADCINB6\n```\n\n序列发生器的工作模式有两种：启停模式和连续转换模式。由ADCTRL1的CONT_RUN位控制。在连续转换模式下，当一次序列转换结束后，会自动从该序列头部开始重新进行转换。当工作在启停模式下的时候，序列发生器完成一次转换后会停留在最后状态，需要先**手动复位**后才能在下一次SOC（start of conversion）信号到来时才会重新开始转换。\n\n```c\nAdcRegs.ADCTRL2.bit.RST_SEQ1 = 1;  // 手动复位序列发生器\n```\n\n## 结果读取\n\nADC的采样结果存储在16个16位的ADC结果寄存器里，左对齐，结果占据高12位，所以计算的时候需要右移4位。\n\n$(ADResult >> 4) = \\frac{(V_{i}  - ADCCLO)}{3 V} *4095$\n\nADCLO一般接模拟地，所以为0：\n\n```c\nres = (AdcRegs.RESULT0 >> 4) / 4095 * 3;\n```\n\n\n\n# 十、SPI\n\n串行外设接口，是一种**低速同步串行通信接口**，而SCI是异步通信。\n\n- 异步通信和同步通信的区别在于**收发双方是否使用同一个时钟信号来控制数据收、发移位操作**。\n\n## 工作方式\n\nSPI总线至少包含一根时钟线和数据线。2812使用4线制SPI，以主从方式进行工作，全双工通信。通信系统中通常有一个主设备和多个从设备。\n\n|                     线路名称                     |           功能           |\n| :----------------------------------------------: | :----------------------: |\n|                       SCK                        | 串行时钟线（主设备控制） |\n|                       MISO                       |    主机输入/从机输出     |\n|                       MOSI                       |    主机输出/从机输入     |\n| <span style=\"text-decoration:overline\">CS</span> | 是低电平有效的从机选择线 |\n\nSPI的波特率 = SPICLK <= LSPCLK/4。实际使用时要确保小于从机的最大允许速率。\n\n<img src=\"..\\img\\DSP\\spi.png\" alt=\"spi\" style=\"zoom:75%;\" />\n\n"}]